(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{1291:function(t,a,e){t.exports=e.p+"assets/img/free-chunk.3f0b7972.png"},1292:function(t,a,e){t.exports=e.p+"assets/img/allocated-chunk.d0b47508.png"},1293:function(t,a,e){t.exports=e.p+"assets/img/arena-single-segment.efa672c8.png"},1294:function(t,a,e){t.exports=e.p+"assets/img/arena-multi-segments.fc9336d5.png"},1295:function(t,a,e){t.exports=e.p+"assets/img/fast-bin.2889fd49.png"},1296:function(t,a,e){t.exports=e.p+"assets/img/unsorte small large.08c56917.png"},1297:function(t,a,e){t.exports=e.p+"assets/img/main arena.e1e2d84d.png"},1298:function(t,a,e){t.exports=e.p+"assets/img/thread arena.6bdf39bd.png"},1299:function(t,a,e){t.exports=e.p+"assets/img/申请流程.bb107eba.png"},1300:function(t,a,e){t.exports=e.p+"assets/img/释放流程.9b9146a4.png"},1734:function(t,a,e){"use strict";e.r(a);var s=e(42),c=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_1-概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[t._v("#")]),t._v(" 1 概述")]),t._v(" "),s("p",[t._v("内存分配器ptmalloc，即glibc中的malloc，实现了 malloc()，free()以及一组其它的函数，以提供动态内存管理的支持。分配器处在用户程序和内核之间，它响应用户的分配请求，向操作系统申请内存，然后将其返回给用户程序。\n为了保持高效的分配，分配器一般都会预先分配一块大于用户请求的内存，并通过某种算法管理这块内存。来满足用户的内存分配要求，用户释放掉的内存也并不是立即就返回给操作系统，相反，分配器会管理这些被释放掉的空闲空间，以应对用户以后的内存分配要求。也就是说，分配器不但要管理已分配的内存块，还需要管理空闲的内存块，当响应用户分配要求时，分配器会首先在空闲空间中寻找一块合适的内存给用户，在空闲空间中找不到的情况下才分配一块新的内存。\n"),s("br"),s("br")]),t._v(" "),s("h1",{attrs:{id:"_2-malloc数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-malloc数据结构"}},[t._v("#")]),t._v(" 2 malloc数据结构")]),t._v(" "),s("h2",{attrs:{id:"_2-1-内存管理结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-内存管理结构"}},[t._v("#")]),t._v(" 2.1 内存管理结构")]),t._v(" "),s("h3",{attrs:{id:"_2-1-1-chunk"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-chunk"}},[t._v("#")]),t._v(" 2.1.1 chunk")]),t._v(" "),s("p",[t._v("chunk原意是块，用在内存中表示的意思就是一块内存，chunk是glibc内存管理的最小单位，其数据结构如下图所示\n"),s("center",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:e(1291)}}),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:e(1292)}})])],1),t._v(" "),s("p",[t._v("chunk中几个关键的成员有prev_size、mchunk_size、fd和bk，其作用分别为："),s("br"),t._v(" "),s("br"),t._v("prev_size："),s("br"),t._v("如果前一个chunk是free chunk，则这个内容保存的是前一个chunk的大小。 如果前一个chunk是allocated chunk，则这个区域保存的是前一个chunk的用户数据；")]),t._v(" "),s("p",[s("br"),t._v("mchunk_size："),s("br"),t._v("\n当前chunk的大小。最后的 3 位作为标志位，具体为："),s("br"),t._v("第0比特位用于表示前一个chunk是否为allocated chunk，而当前是不是chunk allocated可以通过查询下一个chunk的这个标志位来得知；"),s("br"),t._v("第1比特位用于标记该chunk是否是通过系统调用申请的（子线程是mmap，主线程则是通过 brk）。如果是，则该chunk不再由后续将会介绍的内存管理数据结构来标记，申请释放流程将简化；"),s("br"),t._v("第2比特位用于标记该chunk是否属于主分配区，关于分配区将在下文详细介绍。")]),t._v(" "),s("p",[s("br"),t._v("fd:"),s("br"),t._v(" 前向指针，即指向当前chunk在同一个bin的下一个chunk的指针，仅chunk未使用的时候存在。")]),t._v(" "),s("p",[s("br"),t._v("bk: "),s("br"),t._v("后向指针，即指向当前chunk在同一个bin的上一个chunk的指针，仅chunk未使用的时候存在。")]),t._v(" "),s("h3",{attrs:{id:"_2-1-2-arena"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-arena"}},[t._v("#")]),t._v(" 2.1.2 arena")]),t._v(" "),s("p",[t._v("arena一般称为分配区，是一个结构体，内含指向各自类型内存块的指针等元素，每个线程在申请内存时会获取一个。分配区分为主分配区和thread分配区，前者仅有一个，其余均为thread分配区。当新创建的线程需要申请内存时，将从一个全局的链表中获取一个空闲的分配区，如果没有得到且分配区数量没有超过最大值（M_ARENA_MAX），malloc将会新建一个。\n"),s("br"),s("br")]),t._v(" "),s("h3",{attrs:{id:"_2-2-3-heap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-heap"}},[t._v("#")]),t._v(" 2.2.3 heap")]),t._v(" "),s("p",[t._v("heap包括帧头和内存块， glibc以heap为单位从操作系统批量申请和释放内存。\n主分配区有一个heap，thread分配区在刚创建时也只有一个，当超过一定大小时会新增heap，heap直接以链表形式相连，数量没有限制，单个heap最大默认64M。新建heap时里面只有一个chunk，称为top chunk，每次申请内存时都会从top chunk中分裂出一块chunk，而top chunk本身则始终位于heap的末端。")]),t._v(" "),s("p",[t._v("下图是只有一个heap的main arena和thread arena的内存分布图：\n"),s("center",[s("img",{staticStyle:{zoom:"40%"},attrs:{src:e(1293)}})]),t._v("\n下图是一个thread arena中含有多个heap的情况：\n"),s("center",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:e(1294)}})]),t._v("\n从以上两图可以看出，thread arena只含有一个arena，却有两个heap_info（即 heap header）。由于两个heap是通过mmap从操作系统申请的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，glibc的malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了arena，这样就构成了一个单链表，方便后续管理。\n"),s("br"),s("br")],1),t._v(" "),s("h2",{attrs:{id:"_2-2-内存管理链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-内存管理链表"}},[t._v("#")]),t._v(" 2.2 内存管理链表")]),t._v(" "),s("p",[t._v("glibc提供了几种链表来管理不同大小的chunk。其中，除tcache外，其余均为arena结构体中的成员变量。\n"),s("br"),s("br")]),t._v(" "),s("h3",{attrs:{id:"_2-2-1-tcache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-tcache"}},[t._v("#")]),t._v(" 2.2.1 tcache")]),t._v(" "),s("p",[t._v("tcache是glibc为了提升小块内存申请释放性能引入的缓存机制。单个tcache有64个链表项，每一项里面最多可保存7块大小相同的chunk，tcache链表本身的数据结构从分配区管理的heap中申请，线程退出时释放回原heap，由于tcache是线程变量，每个线程都会有一个自己的tcache，因此理论上数量无上限。\n"),s("br"),s("br")]),t._v(" "),s("h3",{attrs:{id:"_2-2-2-fastbin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-fastbin"}},[t._v("#")]),t._v(" 2.2.2 fastbin")]),t._v(" "),s("p",[t._v("fastbin为管理小块chunk（64位为160字节）的链表，应对频繁申请小块内存的场景。链表项管理的chunk值按一定规律递增，可通过一定的算法算出指定大小的chunk所在的链表项索引，从而找到对应大小的chunk。\n"),s("center",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:e(1295)}})]),t._v(" "),s("br"),s("br")],1),t._v(" "),s("h3",{attrs:{id:"_2-2-3-unsortedbin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-unsortedbin"}},[t._v("#")]),t._v(" 2.2.3 unsortedbin")]),t._v(" "),s("p",[t._v("fastbin中整合的chunk和small chunk、 large chunk free之后的chunk被放入unsortedbin，加速内存申请释放，unsortedbin管理的chunk值无规律。\n"),s("center",[s("img",{staticStyle:{zoom:"60%"},attrs:{src:e(1296)}})]),t._v(" "),s("br"),s("br")],1),t._v(" "),s("h3",{attrs:{id:"_2-2-4-smallbin、largebin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-smallbin、largebin"}},[t._v("#")]),t._v(" 2.2.4 smallbin、largebin")]),t._v(" "),s("p",[t._v("smallbin和largebin管理的chunk值按一定规律递增，可通过一定的算法算出指定大小的chunk所在的链表项索引，从而找到对应大小的chunk。\n"),s("br"),s("br")]),t._v(" "),s("h1",{attrs:{id:"_3-malloc原理分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-malloc原理分析"}},[t._v("#")]),t._v(" 3 malloc原理分析")]),t._v(" "),s("h2",{attrs:{id:"_3-1-malloc缓存模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-malloc缓存模型"}},[t._v("#")]),t._v(" 3.1 malloc缓存模型")]),t._v(" "),s("p",[t._v("为了兼顾性能和内存占用，glibc的malloc通过一系列的内存管理链表实现了一套复杂的内存缓存机制，其基本思想可以由如下两图概括。\n"),s("center",[s("img",{staticStyle:{zoom:"40%"},attrs:{src:e(1297)}}),t._v(" "),s("img",{staticStyle:{zoom:"40%"},attrs:{src:e(1298)}})]),t._v("\n可以看出，当用户需要申请内存时，malloc会先向操作系统申请一个heap，然后对该heap进行切分，根据切分后的内存块的大小交由不同的链表管理。在后续内存申请时，会按照tcache→fastbin→unsortedbin→smallbin/largebin的顺序来获取内存。内存释放过程则与此相反。\n"),s("br"),s("br")],1),t._v(" "),s("h2",{attrs:{id:"_3-2-malloc工作流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-malloc工作流程"}},[t._v("#")]),t._v(" 3.2 malloc工作流程")]),t._v(" "),s("h3",{attrs:{id:"_3-2-1-内存申请流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-内存申请流程"}},[t._v("#")]),t._v(" 3.2.1 内存申请流程")]),t._v(" "),s("center",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:e(1299)}})]),t._v(" "),s("br"),s("br"),t._v(" "),s("h3",{attrs:{id:"_3-2-2-内存释放流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-内存释放流程"}},[t._v("#")]),t._v(" 3.2.2 内存释放流程")]),t._v(" "),s("center",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:e(1300)}})]),t._v(" "),s("br"),s("br"),t._v(" "),s("h1",{attrs:{id:"_4-参数配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-参数配置"}},[t._v("#")]),t._v(" 4 参数配置")]),t._v(" "),s("h2",{attrs:{id:"_4-1-参数列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-参数列表"}},[t._v("#")]),t._v(" 4.1 参数列表")]),t._v(" "),s("p",[t._v("glibc提供了一系列的可调参数，用户可以通过设置环境变量的方式调节这些参数从而改变malloc的一些行为。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("参数名")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("默认值")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("取值范围")]),t._v(" "),s("th",{staticStyle:{"text-align":"left"}},[t._v("作用")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("M_MMAP_MAX")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("65536")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"60pt"}},[t._v(">= 0")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[s("div",{staticStyle:{width:"350pt"}},[t._v("使用mmap分配的最大chunk数，取0时，相当于不使用mmap功能")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("M_MMAP_THRESHOLD")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("128 * 1024（字节）")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"60pt"}},[t._v("0 ~ 32M")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[s("div",{staticStyle:{width:"350pt"}},[t._v("所有大于该值的chunk都使用mmap分配内存。如果未设置此参数且未禁用动态调整时，该值将会被动态调整，具体表现为如果上次申请的内存大于该值，则该值将随之增大；如果用户手动设置了这一参数，则将同时禁用动态调整，该值始终保持不变。")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("M_TOP_PAD")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("0")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"60pt"}},[t._v("-")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[s("div",{staticStyle:{width:"350pt"}},[t._v("内存申请和释放时额外保留的内存量，避免过多的系统调用")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("M_TRIM_THRESHOLD")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("128 * 1024（字节）")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"60pt"}},[t._v("-")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[s("div",{staticStyle:{width:"350pt"}},[t._v("收缩阈值，当arena的top值超过收缩阈值将触发收缩操作把多余的内存还给操作系统。如果未设置此参数且未禁用动态调整时，该值将会被动态调整，具体表现为当M_MMAP_THRESHOLD更新时，该值随之更新为前者的两倍；如果用户手动设置了这一参数，则将同时禁用动态调整，该值始终保持不变。")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("M_ARENA_MAX")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("CPU核数 * 8")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"60pt"}},[t._v("-")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[s("div",{staticStyle:{width:"350pt"}},[t._v("arena最大数量")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("M_ARENA_TEST")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("8")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"60pt"}},[t._v("-")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[s("div",{staticStyle:{width:"350pt"}},[t._v("限制arena数量，只有当进程现有的arena不足且需求量超过M_ARENA_TEST时才会触发修改arena数量上限的动作。如果设置了M_ARENA_MAX，将忽略M_ARENA_TEST")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("tcache_count")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("7")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"60pt"}},[t._v(">= 0")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[s("div",{staticStyle:{width:"350pt"}},[t._v("设置tcache的链表bin数量，当取0时，多余的chunk不会放到tcache里面，相当于关闭了tcache，如："),s("br"),s("code",[t._v("export GLIBC_TUNABLES=glibc.malloc.tcache_count=0")])])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("tcache_unsorted_limit")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"120pt"}},[t._v("0")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"60pt"}},[t._v(">= 0")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[s("div",{staticStyle:{width:"350pt"}},[t._v("限制tcache从unsorted bin中获取chunk的数量，当取0时，不做限制")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}}),t._v(" "),s("td",{staticStyle:{"text-align":"center"}}),t._v(" "),s("td",{staticStyle:{"text-align":"center"}}),t._v(" "),s("td",{staticStyle:{"text-align":"left"}})])])]),t._v(" "),s("p",[s("br"),s("br")]),t._v(" "),s("h2",{attrs:{id:"_4-2-使用环境变量设置参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-使用环境变量设置参数"}},[t._v("#")]),t._v(" 4.2 使用环境变量设置参数")]),t._v(" "),s("h3",{attrs:{id:"_4-2-1-兼容模式环境变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1-兼容模式环境变量"}},[t._v("#")]),t._v(" 4.2.1 兼容模式环境变量")]),t._v(" "),s("p",[t._v("这一方式与低于2.26版本的glibc兼容，但是没有tcache相关的设置。\n示例：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("# export MALLOC_ARENA_MAX=1  \n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("h3",{attrs:{id:"_4-2-2-tunables模式环境变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-tunables模式环境变量"}},[t._v("#")]),t._v(" 4.2.2 tunables模式环境变量")]),t._v(" "),s("p",[t._v("这一方式适用于2.26及以上的glibc版本，默认使用")]),t._v(" "),s("p",[t._v("示例：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("# GLIBC_TUNABLES=glibc.malloc.mmap_max=1:glibc.malloc.top_pad=1\n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("h1",{attrs:{id:"_5-调测工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-调测工具"}},[t._v("#")]),t._v(" 5 调测工具")]),t._v(" "),s("p",[t._v("malloc_stats是glibc提供的一个可用统计本进程具体的内存使用情况的接口，精确到字节， malloc_stats()函数声明如下：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("#include<stdlib.h>  \n#include<malloc.h>  \nvoid malloc_stats(void);  \n")])])]),s("p",[t._v("malloc_stats()可以在编写代码时加入编译宏来使用，也可以在gdb中直接调用。malloc_stats()执行结果如下：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Arena 0:                      //分配区编号，这里只有一个线程\nsystem bytes     =     135168 //本线程从操作系统获得的动态内存，这里是132KB  \nin use bytes     =       1152 //本线程在使用的动态内存，1152字节  \nTotal (incl. mmap):           //总的使用情况，各个线程使用动态内存的累加值  \nsystem bytes     =     135168 //本进程从操作系统获得的动态内存，这里是132KB  \nin use bytes     =       1152 //本进程在使用的动态内存，1152字节  \nmax mmap regions =          0 //使用mmap区域的个数  \nmax mmap bytes   =          0 //mmap区域对应内存大小  \n")])])])],1)}),[],!1,null,null,null);a.default=c.exports}}]);