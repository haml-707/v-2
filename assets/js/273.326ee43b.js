(window.webpackJsonp=window.webpackJsonp||[]).push([[273],{1660:function(e,t,r){"use strict";r.r(t);var s=r(42),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"qemu-fuzzer学习"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#qemu-fuzzer学习"}},[e._v("#")]),e._v(" Qemu Fuzzer学习")]),e._v(" "),r("blockquote",[r("p",[e._v("本文章来自于"),r("a",{attrs:{href:"https://summer.iscas.ac.cn/",target:"_blank",rel:"noopener noreferrer"}},[e._v("开源软件供应链点亮计划"),r("OutboundLink")],1),e._v("的openEuler社区项目\n项目名称："),r("a",{attrs:{href:"https://gitee.com/openeuler-competition/summer2021-112",target:"_blank",rel:"noopener noreferrer"}},[e._v("No.112 qemu设备fuzz测试完善"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),r("p",[e._v("一提到 Qemu + Fuzz 的组合，我首先想起的是AFL的Qemu模式，或者是各种使用虚拟化技术对IoT设备进行Fuzzing的工具。")]),e._v(" "),r("p",[e._v("而本文学习的是Qemu自身的Fuzzing框架，即对Hypervisor的Fuzzing。它借助Qtest框架模拟Guest OS对设备的读写，并使用LibFuzzer的启发式算法提供数据驱动。该框架最早源于"),r("a",{attrs:{href:"https://summerofcode.withgoogle.com/archive/2019/projects/6200259867312128/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("Google Summer of Code 2019")]),r("OutboundLink")],1),e._v("项目，在Qemu5.0.0版本后被加入到master分支中。")]),e._v(" "),r("h2",{attrs:{id:"qemu-设备模拟原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#qemu-设备模拟原理"}},[e._v("#")]),e._v(" Qemu 设备模拟原理")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.qemu.org/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("Qemu")]),r("OutboundLink")],1),e._v("是一款开源的虚拟化和仿真工具，由"),r("a",{attrs:{href:"https://bellard.org/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("Fabrice Bellard")]),r("OutboundLink")],1),e._v("实现。Qemu支持两种模式的仿真：")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("system mode")]),e._v("：对于CPU，内存以及外设的全系统仿真，提供KVM，Hyper-V等加速方式")]),e._v(" "),r("li",[r("code",[e._v("user mode")]),e._v("：通过指令翻译在一种架构的CPU上运行另一种CPU架构的二进制程序")])]),e._v(" "),r("p",[e._v("首先需要理解虚拟化的本质在于：使用一个用户态的程序，在只使用用户态内存的情况下，来处理模拟设备对内存以及其他特殊硬件的访问。由于Qemu需要仿真不同架构，不同指令集的设备，所以其采用了OOP的编程思想，实现了"),r("code",[e._v("Qemu Object Model")]),e._v("来描述设备模型。")]),e._v(" "),r("ul",[r("li",[e._v("设备模型：每个模拟出来的设备都对应一个TypeInfo对象，由设备名唯一标识，并存储在hash table中")]),e._v(" "),r("li",[e._v("设备启动：启动设备需要经过设备注册，设备类型初始化，设备实例化等步骤，")]),e._v(" "),r("li",[e._v("指令翻译：真正运行时，Qemu通过TCG（软件）或者KVM（硬件）等方式，接受模拟设备的指令，并翻译到物理设备上执行。这样会带来性能开销，相比起来硬件虚拟化带来的开销更低")]),e._v(" "),r("li",[e._v("内存模拟：Qemu负责提供内存映射给客户机。当客户机访问这部分内存以便写磁盘时，Qemu会捕获访问，并且将请求传送给qemu的IDE控制器设备模型，模型会解析I/O请求并且通过宿主机的系统调用来模拟指令。最终将客户机的内存拷贝至宿主机的磁盘中。")])]),e._v(" "),r("p",[e._v("总之，在Guest OS中，它认为自己可以直接和Host OS上的硬件设备打交道，Qemu充当了中间人的角色，可以用下图来概括：")]),e._v(" "),r("div",{staticClass:"language-asciidoc= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("+----------+ +----------+ +----------+ +----------+ +----------+\n| UserSpace| | UserSpace| | UserSpace| | UserSpace| | UserSpace|\n+----------+ +----------+ +----------+ +----------+ +----------+\n|  Linux   | | Mac OS   | | Windows  | | Linux    | | Solaris  |\n+----------+ +----------+ +----------+ +----------+ +----------+\n|  Drivers | | Drivers  | | Drivers  | | Drivers  | | Drivers  |\n+----------+ +----------+ +----------+ +----------+ +----------+\n+----------+ +----------+ +----------+ +----------+ +----------+\n| QEMU x86 | | QEMU x86 | | QEMU ARM | | QEMU PPC | | QEMU MIPS|\n+----------+ +----------+ +----------+ +----------+ +----------+\n+----------+-+----------+-+----------+-+----------+-+----------+\n|               Host System:Linux,Mac OS,Windows               |\n+--------------------------------------------------------------+\n+--------------------------------------------------------------+\n|         Hardware:CPU,memory,disk,networking,USB,etc          |\n+--------------------------------------------------------------+\n")])])]),r("blockquote",[r("p",[e._v("关于Qemu设备模拟的方法，可以参考"),r("a",{attrs:{href:"LLVMFuzzerTestOneInput"}},[r("code",[e._v("User Documentation")])]),e._v("\n关于Qemu设备模拟的理解，可以参考"),r("a",{attrs:{href:"https://www.qemu.org/2018/02/09/understanding-qemu-devices/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("understanding Qemu devices")]),r("OutboundLink")],1),e._v("\nQemu作者的论文："),r("a",{attrs:{href:"https://www.usenix.org/legacy/event/usenix05/tech/freenix/full_papers/bellard/bellard.pdf#:~:text=We%20present%20the%20internals%20of%20QEMU%2C%20a%20fast,one%20target%20CPU%20can%20be%20runon%20another%20CPU.",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("QEMU, a Fast and Portable Dynamic Translator")]),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"qemu-fuzzer-的使用方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#qemu-fuzzer-的使用方法"}},[e._v("#")]),e._v(" Qemu Fuzzer 的使用方法")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://qemu.readthedocs.io/en/latest/devel/fuzzing.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("文档说明"),r("OutboundLink")],1)]),e._v(" "),r("h3",{attrs:{id:"实验环境"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实验环境"}},[e._v("#")]),e._v(" 实验环境")]),e._v(" "),r("p",[e._v("采用了本机的WSL上的Docker环境")]),e._v(" "),r("div",{staticClass:"language-bash= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('root@31b23c4c00b7:~/qemu# lscpu\nArchitecture:                    x86_64\nCPU op-mode(s):                  32-bit, 64-bit\nByte Order:                      Little Endian\nCPU(s):                          16\nroot@31b23c4c00b7:~/qemu# cat /etc/os-release\nNAME="Ubuntu"\nVERSION="20.04.2 LTS (Focal Fossa)"\n')])])]),r("h4",{attrs:{id:"环境问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#环境问题"}},[e._v("#")]),e._v(" 环境问题")]),e._v(" "),r("ul",[r("li",[e._v("描述：Qemu的Fuzzing还没有适配AArch64架构，虽然编译成功，但运行报错。")])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/2161923b370fbd9f89318104b70fad11.png",alt:""}})]),e._v(" "),r("ul",[r("li",[e._v("解决方案：适配AArch64下的Qemu Fuzzing正是本项目要做的内容，但在学习阶段，还是采用x86环境来运行。")])]),e._v(" "),r("h4",{attrs:{id:"版本问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#版本问题"}},[e._v("#")]),e._v(" 版本问题")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("描述：官网给出的示例使用的是clang-8，而最新的clang版本已经来到了clang-14，如果采用较新的版本，则会在编译阶段报错（原因为开启了Werror）。")])]),e._v(" "),r("li",[r("p",[e._v("解决方案：")]),e._v(" "),r("ul",[r("li",[e._v("（推荐）直接采用包管理器（apt/dnf）安装clang")]),e._v(" "),r("li",[e._v("git checkout到LLVM8-10之间的版本")]),e._v(" "),r("li",[e._v("到"),r("a",{attrs:{href:"https://releases.llvm.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方Release页面"),r("OutboundLink")],1),e._v("下载LLVM8-10之间版本的源代码")])])])]),e._v(" "),r("div",{staticClass:"language-bash= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# sudo apt/dnf search xxx 可以查看包管理器中包含的软件以及对应版本，默认为clang-10\nsudo apt/dnf install clang llvm compiler-rt\n")])])]),r("h4",{attrs:{id:"docker打包"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker打包"}},[e._v("#")]),e._v(" Docker打包")]),e._v(" "),r("p",[e._v("为了方便部署，采用了docker的形式来配置实验环境："),r("a",{attrs:{href:"https://hub.docker.com/repository/docker/cascadessjtu/qemu_fuzz",target:"_blank",rel:"noopener noreferrer"}},[e._v("镜像地址"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("h3",{attrs:{id:"简单使用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简单使用"}},[e._v("#")]),e._v(" 简单使用")]),e._v(" "),r("p",[e._v("配置好环境后，通过如下命令编译运行Fuzzing程序，即显示LibFuzzer的输出。")]),e._v(" "),r("div",{staticClass:"language-bash= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("CC=clang-10 CXX=clang++-10 ./configure --enable-sanitizers --enable-fuzzing\n# qemu-fuzz-isa isa为模拟设备的架构\nmake qemu-fuzz-i386 qemu-fuzz-aarch64\n# 查看可用的Fuzzing对象\nbuild/qemu-fuzz-i386 --fuzz-target=FUZZ_NAME\n")])])]),r("p",[e._v("除了上述命令外，Qemu Fuzzer还支持LibFuzzer的编译指令，可以通过"),r("code",[e._v("-help=1")]),e._v("来查看")]),e._v(" "),r("p",[e._v("对于Fuzzing的结果，可以考虑采用"),r("a",{attrs:{href:"https://qemu.readthedocs.io/en/latest/devel/fuzzing.html#generating-coverage-reports",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("Clang Sanitizer")]),r("OutboundLink")],1),e._v("查看。该工具需要使用CORPUS参数，并对编译指令进行一定的修改。在Fuzzing结束后，通过"),r("code",[e._v("llvm-cov")]),e._v("命令将生成的"),r("code",[e._v("default.profraw")]),e._v("文件转化为"),r("code",[e._v(".html")]),e._v("的可视化文件。")]),e._v(" "),r("h3",{attrs:{id:"添加自定义fuzzer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#添加自定义fuzzer"}},[e._v("#")]),e._v(" 添加自定义Fuzzer")]),e._v(" "),r("p",[e._v("添加一个新的Fuzzer需要以下三个步骤：")]),e._v(" "),r("ol",[r("li",[e._v("编写Fuzzer源文件"),r("code",[e._v("foo-device-fuzz.c")]),e._v("，放在"),r("code",[e._v("tests/qtest/fuzz")]),e._v("目录下")]),e._v(" "),r("li",[e._v("参考已有的Fuzzer，使用libqos和libqtest中的API与模拟设备通信")]),e._v(" "),r("li",[e._v("在"),r("code",[e._v("tests/qtest/fuzz/meson.build")]),e._v("文件中注册该Fuzzer")])]),e._v(" "),r("h3",{attrs:{id:"通用fuzzer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通用fuzzer"}},[e._v("#")]),e._v(" 通用Fuzzer")]),e._v(" "),r("p",[e._v("为某些特定的设备类型写Fuzzer是非常费时费力的事情，尤其是那些libqos并没有包含的设备驱动。Qemu提供了"),r("code",[e._v("generic-fuzz")]),e._v("的选项，用于对所有设备进行初步的Fuzzing，包括设备的PIO，MMIO和DMA。如果要启用generic-fuzz，至少需要设置以下两个环境变量：")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("QEMU_FUZZ_ARGS=")]),e._v("：配置设备所需要的参数，比如网卡，用户名")]),e._v(" "),r("li",[r("code",[e._v("QEMU_FUZZ_OBJECTS")]),e._v("=：采用字符串匹配的方式来指定Fuzzing的内存区域。可以用"),r("code",[e._v("./qemu-fuzz-i386 --fuzz-target=generic-fuzz -runs=0")]),e._v("来检查匹配到的内存区域。如果匹配到的内存区域越多，Fuzzing的"),r("code",[e._v("input-space")]),e._v("就越大，越难发现导致该设备crash的输入，所以"),r("code",[e._v("MemoryRegion")]),e._v("的选取要适度。")])]),e._v(" "),r("h3",{attrs:{id:"集成oss-fuzz"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集成oss-fuzz"}},[e._v("#")]),e._v(" 集成OSS-Fuzz")]),e._v(" "),r("p",[e._v("OSS-Fuzz是集成式的Fuzzing工具，它默认对所有的对象进行Fuzz。由于通用Fuzzer的启动需要额外对环境变量进行设置，所以Qemu在"),r("code",[e._v("tests/qtest/fuzz/generic_fuzz_configs.h")]),e._v("文件中自定义了一些设备类型，用于OSS-Fuzz。开发者可以在该文件中添加新的设备类型，官方也提供了用于搭建环境的"),r("a",{attrs:{href:"https://github.com/google/oss-fuzz/blob/master/projects/qemu/Dockerfile",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("Dockerfile")]),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("h3",{attrs:{id:"crash复现工具"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#crash复现工具"}},[e._v("#")]),e._v(" crash复现工具")]),e._v(" "),r("p",[e._v("当复现crash的时候，需要不包含Fuzzer的Qemu，这样可以过滤调误报，并增强调试功能。可以使用OSS-Fuzz的脚本来创建一个"),r("code",[e._v("one-line reproducer")]),e._v("。")]),e._v(" "),r("h3",{attrs:{id:"fuzzer生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fuzzer生命周期"}},[e._v("#")]),e._v(" Fuzzer生命周期")]),e._v(" "),r("p",[e._v("Qemu Fuzzer为LibFuzzer提供了两处入口点，在LibFuzzer自己的main函数之后调用：")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("LLVMFuzzerInitialize")]),e._v("：Fuzzing开始前调用，初始化环境")]),e._v(" "),r("li",[r("code",[e._v("LLVMFuzzerTestOneInput")]),e._v("：每个Fuzzing任务运行时调用，提供输入并在Fuzzing结束后重置状态")])]),e._v(" "),r("p",[e._v("因为Fuzzer的进程会在每次Fuzzing运行后被重置（reset），所以Qemu的状态也需要重置，有两种方法来实现重置，各有优劣。")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Reboot")]),e._v("：在每次运行之间重启Guest OS")]),e._v(" "),r("li",[r("code",[e._v("Fork")]),e._v("：在子进程中运行test case，和AFL的"),r("code",[e._v("fork-server")]),e._v("模式很相似")])]),e._v(" "),r("h2",{attrs:{id:"qemu-fuzzer的依赖库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#qemu-fuzzer的依赖库"}},[e._v("#")]),e._v(" Qemu Fuzzer的依赖库")]),e._v(" "),r("p",[e._v("Qemu Fuzzer实现主要依赖的是libqtest和libqos两个库，它们的关系可以参考"),r("a",{attrs:{href:"https://www.linux-kvm.org/images/4/43/03x09-TestingQEMU.pdf",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("Testing QEMU emulated devices using qtest")]),r("OutboundLink")],1),e._v("，这篇文章介绍了qtest的基本原理，提供的API函数，并给出了添加testcase的方法。")]),e._v(" "),r("h3",{attrs:{id:"libqtest"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#libqtest"}},[e._v("#")]),e._v(" libqtest")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/qemu/qemu/tree/master/tests/qtest/libqtest.c",target:"_blank",rel:"noopener noreferrer"}},[e._v("代码路径"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://qemu.readthedocs.io/en/latest/devel/qtest.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("文档说明"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("Qtest是一个用于对Qemu模拟出的硬件设备做单元测试的框架，它由"),r("code",[e._v("Qtest Client")]),e._v("，"),r("code",[e._v("Qtest Server")]),e._v("两部分组成。两者之间通过UNIX Socket通信，支持PIO，MMIO，中断，QMP等指令。")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("Qtest Client")]),e._v("：它是为某个设备编写的驱动程序，按照自底向上的封装顺序，它依赖于glib单元测试框架，libqtest，libqos和qgraph。如果需要添加新的测试程序，需要如下四个步骤：\n"),r("ol",[r("li",[e._v("在Qtest目录下编写新的测试代码"),r("code",[e._v("tests/qtest/foo-test.c")])]),e._v(" "),r("li",[e._v("在Makefile.include中添加编译指令")]),e._v(" "),r("li",[e._v("编译："),r("code",[e._v("make tests/qtest/foo-test.c")])]),e._v(" "),r("li",[e._v("运行：")])]),e._v(" "),r("div",{staticClass:"language-bash= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("QTEST_LOG=1 QTEST_QEMU_BINARY=i386-softmmu/qemu-system-i386 tests/qtest/foo-test`\n")])])])]),e._v(" "),r("li",[r("code",[e._v("Qtest Server")]),e._v("：它和TCG，KVM的功能类似，是一种加速器（accelerator），通过编译指令"),r("code",[e._v("-machine accel=qtest")]),e._v("注册。在普通的使用场景中，VCPU直接和虚拟硬件交互；而测试场景中，Qtest直接和虚拟硬件交互，充当了Qtest Client和虚拟硬件的中间角色。Qtest用于验证设备的行为是否正确，实际上并没有启动Guest OS。")])]),e._v(" "),r("p",[e._v("运行时，"),r("code",[e._v("libqtest.c")]),e._v("将启动Qemu为子进程。Qemu的启动主函数在"),r("code",[e._v("vl.c")]),e._v("中，在测试场景中，调用"),r("code",[e._v("qtest.c")]),e._v("的"),r("code",[e._v("qtest_init()")]),e._v("函数，初始化Qtest Server。")]),e._v(" "),r("p",[e._v("两者的关系可以用下图表示：")]),e._v(" "),r("div",{staticClass:"language-asciidoc= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("+----------------+  socket  +----------------+----------------------+\n|  Qtest Client  +----------\x3e  Qtest Server  |                      |\n+----------------+          +-------+--------+                      |\n+----------------+                  |        |         Qemu         |\n|  Qgraph        |               PIO|MMIO    |                      |\n+----------------+                  |        |                      |\n+----------------+          +-------v--------+----------------------+\n|  libqos        |          |          Hardware Emulation           |\n+----------------+          +---------------------------------------+\n+----------------+\n|  libqtest      |\n+----------------+\n+----------------+\n|  glib test     |\n+----------------+\n")])])]),r("h3",{attrs:{id:"libqos"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#libqos"}},[e._v("#")]),e._v(" libqos")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/qemu/qemu/tree/master/tests/qtest/libqos/libqos.c",target:"_blank",rel:"noopener noreferrer"}},[e._v("代码路径"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://qemu.readthedocs.io/en/latest/devel/qtest.html?highlight=libqos",target:"_blank",rel:"noopener noreferrer"}},[e._v("文档说明"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("libqos是用于编写qtest case的设备驱动框架，提供了关于"),r("code",[e._v("memory")]),e._v("，"),r("code",[e._v("PCI")]),e._v("，"),r("code",[e._v("virtio")]),e._v("的API函数。它的功能主要有以下两个：")]),e._v(" "),r("ul",[r("li",[e._v("相当于总线的wrapper，为每类总线都实现了特定的函数")]),e._v(" "),r("li",[e._v("统一了设备访问的模型，简化了开发者的工作")])]),e._v(" "),r("h2",{attrs:{id:"qemu-fuzzer-的整体流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#qemu-fuzzer-的整体流程"}},[e._v("#")]),e._v(" Qemu Fuzzer 的整体流程")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/qemu/qemu/tree/master/tests/qtest/fuzz",target:"_blank",rel:"noopener noreferrer"}},[e._v("代码路径"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://qemu.readthedocs.io/en/latest/devel/fuzzing.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("文档说明"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("以上的两个依赖库都是为Qemu的功能性测试设计，依赖于测试输入的选取。而Fuzzing正是通过对输入增加随机性和变异算法来提高测试输入的质量。从而可以使用LibFuzzer对Qtest的输入进行HOOK，提高Qtest的测试效率。综上所述，Qemu Fuzzer的整体结构如图所示。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/f269d3ace4fe504117d7fe4e2a253375.png",alt:""}})]),e._v(" "),r("p",[e._v("从源代码的角度来看：")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("fuzz.h")]),e._v("：定义了实现一个Fuzz Target用到的接口和数据结构，以及与LibFuzzer之间的交互")]),e._v(" "),r("li",[r("code",[e._v("fork_fuzz.h")]),e._v("：定义了并发Fuzzer之间的共享内存")]),e._v(" "),r("li",[r("code",[e._v("qos_fuzz.h")]),e._v("：定义了libqos在qtest上的进一步封装的接口")]),e._v(" "),r("li",[r("code",[e._v("generic_fuzz_configs.h")]),e._v("：定义了通用的Fuzzer设置")]),e._v(" "),r("li",[r("code",[e._v("virtio_xxx_fuzz.h")]),e._v("：实现了virtio设备（net，blk，scsi）的Fuzz Target")])]),e._v(" "),r("h2",{attrs:{id:"qemu-fuzzer-的用例分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#qemu-fuzzer-的用例分析"}},[e._v("#")]),e._v(" Qemu Fuzzer 的用例分析")]),e._v(" "),r("p",[e._v("Qemu的"),r("a",{attrs:{href:"https://wiki.qemu.org/Documentation/GettingStartedDevelopers",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("Developer documentation")]),r("OutboundLink")],1),e._v("中写道：")]),e._v(" "),r("blockquote",[r("p",[e._v("QEMU does not have a high level design description document - only the source code tells the full story.")])]),e._v(" "),r("p",[e._v("所以作为Qemu的开发者，阅读源码非常关键。本节以virtio-net设备为例，分析Qemu Fuzzing的流程，代码路径为"),r("a",{attrs:{href:"https://github.com/qemu/qemu/tree/master/tests/qtest/fuzz/virtio_net_fuzz.c",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("tests/qtest/fuzz/virto_net_fuzz.c")]),r("OutboundLink")],1),e._v("。virtio是一种半虚拟化的技术，需要Host OS提供对设备的emulation，Guest OS负责对设备的驱动。工作模式如下图所示：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/8cbe7f371f062202bb88928900b3a481.png",alt:""}})]),e._v(" "),r("p",[e._v("实现方面，以自顶向下的逻辑进行说明：")]),e._v(" "),r("ul",[r("li",[e._v("首先，实现注册函数"),r("code",[e._v("register_virtio_net_fuzz_targets()")]),e._v("。使用libqos提供的"),r("code",[e._v("fuzz_add_qos_target()")]),e._v("函数添加了三个Fuzzing对象。该函数是libqos对于"),r("code",[e._v("fuzz_add_target()")]),e._v("函数的wrapper，其原型如下：")])]),e._v(" "),r("div",{staticClass:"language-cpp= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("void fuzz_add_qos_target(\n        FuzzTarget *fuzz_opts,\n        const char *interface,\n        QOSGraphTestOptions *opts\n        );\n")])])]),r("ul",[r("li",[e._v("最后，修改"),r("a",{attrs:{href:"https://github.com/qemu/qemu/tree/master/tests/qtest/fuzz/fuzz.c",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("meson.build")]),r("OutboundLink")],1),e._v("文件，添加条件编译选项。")])]),e._v(" "),r("p",[e._v("接下来，以"),r("code",[e._v("virtio-net-socket")]),e._v("为主，对Fuzzing对象的参数以及参数中涉及到的函数进行分析")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("virtio-net-socket")]),e._v("：")])]),e._v(" "),r("div",{staticClass:"language-cpp= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('fuzz_add_qos_target(&(FuzzTarget){\n        .name = "virtio-net-socket",\n        .description = "Fuzz the virtio-net virtual queues. Fuzz incoming "\n        "traffic using the socket backend",\n        .pre_fuzz = &virtio_net_pre_fuzz,\n        .fuzz = virtio_net_fork_fuzz,},\n        "virtio-net",\n        &(QOSGraphTestOptions){.before = virtio_net_test_setup_socket}\n        );\n')])])]),r("p",[e._v("第一个参数为指向FuzzTarget的临时对象的指针。该对象由"),r("a",{attrs:{href:"https://github.com/qemu/qemu/tree/master/tests/qtest/fuzz/fuzz.c",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("fuzz.h")]),r("OutboundLink")],1),e._v("定义，含标识信息和许多与Fuzzing特性相关的回调函数。介绍如下：")]),e._v(" "),r("div",{staticClass:"language-asciidoc= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("+-------------+-----------------------------------------------------------+-------------------------------------------------------------------------+\n| Field       | Declaration                                               | Description                                                             |\n+-------------+-----------------------------------------------------------+-------------------------------------------------------------------------+\n| name        | const char *name                                          | target identifier (passed to --fuzz-target=)                            |\n+-------------+-----------------------------------------------------------+-------------------------------------------------------------------------+\n| description | const char *description                                   | help text                                                               |\n+-------------+-----------------------------------------------------------+-------------------------------------------------------------------------+\n| pre_fuzz    | void(*pre_fuzz)(QTestState *)                             | will run once, after QEMU has been initialized, prior to the fuzz-loop. |\n|             |                                                           | eg: detect the memory map                                               |\n|             |                                                           | Can be NULL                                                             |\n+-------------+-----------------------------------------------------------+-------------------------------------------------------------------------+\n| fuzz        | void(*fuzz)(QTestState *, const unsigned char *, size_t); | accepts and executes an input from LibFuzzer.                           |\n|             |                                                           | this is repeatedly executed during the fuzzing loop.                    |\n|             |                                                           | Its should handle setup, input execution and cleanup.                   |\n|             |                                                           | Cannot be NULL                                                          |\n+-------------+-----------------------------------------------------------+-------------------------------------------------------------------------+\n")])])]),r("p",[e._v("其中，"),r("code",[e._v("virtio_net_pre_fuzz")]),e._v("初始化了qos path和fork fuzz用到的共享内存。"),r("code",[e._v("virtio_net_fork_fuzz")]),e._v("首先fork出子进程，并调用"),r("code",[e._v("virtio_net_fuzz_multi")]),e._v("函数。该函数用自定义的"),r("code",[e._v("vq_action")]),e._v("来管理随机数据，根据数据包到来情况，将其加入"),r("code",[e._v("virtioqueue")]),e._v("中，并kick out出去。随后运行主循环。")]),e._v(" "),r("p",[e._v("第二个参数表示使用的设备接口名称，这里统一为virtio-net。")]),e._v(" "),r("p",[e._v("第三个参数为"),r("a",{attrs:{href:"https://github.com/qemu/qemu/tree/master/tests/qtest/libqos/qgraph.h",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("qgraph.h")]),r("OutboundLink")],1),e._v("提供的关于测试选项的结构体。其中"),r("code",[e._v("before")]),e._v("参数接受原型为"),r("code",[e._v("QOSBeforeTest")]),e._v("的函数。"),r("code",[e._v("virtio_net_test_setup_socket")]),e._v("函数指定了Qemu网络设备的后端为socket。它负责和虚拟设备通信，并将虚拟设备的数据包发送到宿主机的网络设备中。")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("virtio-net-socket-check-use")])])]),e._v(" "),r("div",{staticClass:"language-cpp= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('fuzz_add_qos_target(&(FuzzTarget){\n        .name = "virtio-net-socket-check-used",\n        .description = "Fuzz the virtio-net virtual queues. Wait for the "\n        "descriptors to be used. Timeout may indicate improperly handled "\n        "input",\n        .pre_fuzz = &virtio_net_pre_fuzz,\n        .fuzz = virtio_net_fork_fuzz_check_used,},\n        "virtio-net",\n        &(QOSGraphTestOptions){.before = virtio_net_test_setup_socket}\n        );\n')])])]),r("p",[r("code",[e._v("virtio_net_fork_fuzz_check_used")]),e._v("和"),r("code",[e._v("virtio_net_fork_fuzz")]),e._v("非常相似，不同之处在于调用"),r("code",[e._v("virtio_net_fuzz_multi")]),e._v("函数的时候使用了"),r("code",[e._v("true")]),e._v("。")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("cirtio-net-slirp")])])]),e._v(" "),r("div",{staticClass:"language-cpp= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('fuzz_add_qos_target(&(FuzzTarget){\n        .name = "virtio-net-slirp",\n        .description = "Fuzz the virtio-net virtual queues with the slirp "\n        " backend. Warning: May result in network traffic emitted from the "\n        " process. Run in an isolated network environment.",\n        .pre_fuzz = &virtio_net_pre_fuzz,\n        .fuzz = virtio_net_fork_fuzz,},\n        "virtio-net",\n        &(QOSGraphTestOptions){.before = virtio_net_test_setup_user}\n        );\n')])])]),r("p",[r("code",[e._v("virtio_net_test_setup_user")]),e._v("指定了网络后端的类型为user")]),e._v(" "),r("h2",{attrs:{id:"qemu-fuzzer-案例-cve-2017-12809"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#qemu-fuzzer-案例-cve-2017-12809"}},[e._v("#")]),e._v(" Qemu Fuzzer 案例 CVE-2017-12809")]),e._v(" "),r("p",[e._v("最后，简要分析一个"),r("a",{attrs:{href:"https://unit42.paloaltonetworks.com/unit42-palo-alto-networks-discovers-new-qemu-vulnerability/",target:"_blank",rel:"noopener noreferrer"}},[e._v("由LibFuzzer发现"),r("OutboundLink")],1),e._v("的Qemu上的CVE漏洞。")]),e._v(" "),r("ul",[r("li",[e._v("漏洞描述：该漏洞属于拒绝服务类。当通过IDE硬盘和CD/DVD-ROM模拟器来构建Guest OS时，Guest OS中的特权用户可以通过清除一个空的CDROM设备驱动，造成空指针解引用，进而导致Qemu进程崩溃。")]),e._v(" "),r("li",[e._v("漏洞代码： 在"),r("code",[e._v("hw/ide/core.c")]),e._v("文件中调用"),r("code",[e._v("blk_aio_flush()")]),e._v("函数前没有检查"),r("code",[e._v("s->blk")]),e._v("是否为空")])]),e._v(" "),r("div",{staticClass:"language-asciidoc= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("---\n hw/ide/core.c | 10 +++++++++-\n 1 file changed, 9 insertions(+), 1 deletion(-)\n\ndiff --git a/hw/ide/core.c b/hw/ide/core.c\nindex 0b48b64d3a..bea39536b0 100644\n--- a/hw/ide/core.c\n+++ b/hw/ide/core.c\n@@ -1063,7 +1063,15 @@ static void ide_flush_cache(IDEState *s)\n     s->status |= BUSY_STAT;\n     ide_set_retry(s);\n     block_acct_start(blk_get_stats(s->blk), &s->acct, 0, BLOCK_ACCT_FLUSH);\n-    s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);\n+\n+    if (blk_bs(s->blk)) {\n+        s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);\n+    } else {\n+        /* XXX blk_aio_flush() crashes when blk_bs(blk) is NULL, remove this\n+         * temporary workaround when blk_aio_*() functions handle NULL blk_bs.\n+         */\n+        ide_flush_cb(s, 0);\n+    }\n }\n \n static void ide_cfata_metadata_inquiry(IDEState *s)\n-- \n")])])]),r("ul",[r("li",[r("a",{attrs:{href:"https://lists.gnu.org/archive/html/qemu-devel/2017-08/msg01989.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("漏洞修复"),r("OutboundLink")],1),e._v("：除了在漏洞发生部分增加条件判断以外，还在"),r("code",[e._v("tests/ide-test.c")]),e._v("中增加了测试代码")])]),e._v(" "),r("div",{staticClass:"language-asciidoc= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('---\n tests/ide-test.c | 19 +++++++++++++++++++\n 1 file changed, 19 insertions(+)\n\ndiff --git a/tests/ide-test.c b/tests/ide-test.c\nindex bfd79ddbdc..aa9de065fc 100644\n--- a/tests/ide-test.c\n+++ b/tests/ide-test.c\n@@ -689,6 +689,24 @@ static void test_flush_nodev(void)\n     ide_test_quit();\n }\n \n+static void test_flush_empty_drive(void)\n+{\n+    QPCIDevice *dev;\n+    QPCIBar bmdma_bar, ide_bar;\n+\n+    ide_test_start("-device ide-cd,bus=ide.0");\n+    dev = get_pci_device(&bmdma_bar, &ide_bar);\n+\n+    /* FLUSH CACHE command on device 0 */\n+    qpci_io_writeb(dev, ide_bar, reg_device, 0);\n+    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);\n+\n+    /* Just testing that qemu doesn\'t crash... */\n+\n+    free_pci_device(dev);\n+    ide_test_quit();\n+}\n+\n static void test_pci_retry_flush(void)\n {\n     test_retry_flush("pc");\n@@ -954,6 +972,7 @@ int main(int argc, char **argv)\n \n     qtest_add_func("/ide/flush", test_flush);\n     qtest_a\n     cd qemu\n     git checkout stable-2.10dd_func("/ide/flush/nodev", test_flush_nodev);\n+    qtest_add_func("/ide/flush/empty_drive", test_flush_empty_drive);\n     qtest_add_func("/ide/flush/retry_pci", test_pci_retry_flush);\n     qtest_add_func("/ide/flush/retry_isa", test_isa_retry_flush);\n \n-- \n')])])]),r("ul",[r("li",[e._v("漏洞复现：找到patch前的commit版本，加上新增test中的测试用例，运行qtest程序：")])]),e._v(" "),r("div",{staticClass:"language-bash= extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# 不能直接wget对应的release版本，因为受影响的版本都被修复了\ngit clone https://gitlab.com/qemu-project/qemu.git;cd qemu\ngit checkout stable-2.10\n# 从mailing list中获取patch的作者，找对应的commit\ngit log --author=Hajnoczi\ngit reset --hard=4da97120d51a4383aa96d741a2b837f8c4bbcd0b\n# 构建\nmkdir build;cd build;../configure ----disable-werror\nmake qtest\n")])])]),r("p",[e._v("其实Qemu虚拟机逃逸漏洞已经常见于CTF比赛和CVE中了，比如知名的"),r("a",{attrs:{href:"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-14364",target:"_blank",rel:"noopener noreferrer"}},[e._v("CVE-2020-14364"),r("OutboundLink")],1)]),e._v(" "),r("blockquote",[r("p",[e._v("有错误之处请批评指正，作者联系方式："),r("a",{attrs:{href:"https://cascadeschen.cn",target:"_blank",rel:"noopener noreferrer"}},[e._v("cascades-sjtu"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=a.exports}}]);