(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{1308:function(t,e,n){t.exports=n.p+"assets/img/nuttx.9e0036b5.jpg"},1309:function(t,e,n){t.exports=n.p+"assets/img/tmpfs.695cda96.jpg"},1743:function(t,e,n){"use strict";n.r(e);var r=n(42),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),r("p",[t._v("tmpfs（temporary filesystem）直译为临时文件系统，类似于虚拟磁盘（ramdisk），但ramdisk是一个块设备，而且需要一个mkfs之类的命令格式化后才能使用。而tmpfs是一个独立的文件系统，不是块设备，只要挂载，就可以立即使用。本文将以nuttx-10.0.1的tmpfs为研究对象介绍其基本数据结构和基础接口功能实现。"),r("br"),t._v(" "),r("br")]),t._v(" "),r("h1",{attrs:{id:"数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),r("p",[t._v("tmpfs的源码位于nuttx的fs/tmpfs目录下，只有一个C文件，因此阅读起来相对比较简单，这里先介绍一下tmpfs的关键数据结构。"),r("br"),t._v(" "),r("br")]),t._v(" "),r("h2",{attrs:{id:"object"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object"}},[t._v("#")]),t._v(" object")]),t._v(" "),r("p",[t._v("目录和文件的抽象，从下图几个结构体的对比也可以看出，object结构体可以认为是为了便于统一接口而将文件和目录的结构体进行的抽象，从面向对象的角度来看，object可以理解为file和directory结构体的的父类。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/* The generic form of a TMPFS memory object */\n\nstruct tmpfs_object_s\n{\n  FAR struct tmpfs_dirent_s *to_dirent;\n  struct tmpfs_sem_s to_exclsem;\n\n  size_t   to_alloc;     /* Allocated size of the memory object */\n  uint8_t  to_type;      /* See enum tmpfs_objtype_e */\n  uint8_t  to_refs;      /* Reference count */\n};\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("center",[r("img",{staticStyle:{zoom:"100%"},attrs:{src:n(1308)}})]),t._v(" "),r("br"),r("br"),t._v(" "),r("h2",{attrs:{id:"dirent"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dirent"}},[t._v("#")]),t._v(" dirent")]),t._v(" "),r("p",[t._v("可以理解为检索项，后续将通过dirent来找到对应的object，从源码可以看出，dirent只是在object之外增加了对象的名称。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/* The form of one directory entry */\n\nstruct tmpfs_dirent_s\n{\n  FAR struct tmpfs_object_s *tde_object;\n  FAR char *tde_name;\n};\n")])])]),r("br"),t._v(" "),r("h2",{attrs:{id:"directory"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#directory"}},[t._v("#")]),t._v(" directory")]),t._v(" "),r("p",[t._v("目录，directory里面有一个或多个dirent，目录中的dirent可以指向文件或子目录，从根目录开始文件和目录交织在一起构成一棵tmpfs树。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/* The form of a directory memory object */\n\nstruct tmpfs_directory_s\n{\n  /* First fields must match common TMPFS object layout */\n\n  FAR struct tmpfs_dirent_s *tdo_dirent;\n  struct tmpfs_sem_s tdo_exclsem;\n\n  size_t   tdo_alloc;    /* Allocated size of the directory object */\n  uint8_t  tdo_type;     /* See enum tmpfs_objtype_e */\n  uint8_t  tdo_refs;     /* Reference count */\n\n  /* Remaining fields are unique to a directory object */\n\n  uint16_t tdo_nentries; /* Number of directory entries */\n  struct tmpfs_dirent_s tdo_entry[1];\n};\n")])])]),r("br"),t._v(" "),r("h2",{attrs:{id:"file"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#file"}},[t._v("#")]),t._v(" file")]),t._v(" "),r("p",[t._v("文件，书面地讲是有顺序的字节流。每个文件都有一个可阅读的文件名，用户可以对指定文件名的文件进行读、写、创建删除等操作。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/* The form of a regular file memory object\n *\n * NOTE that in this very simplified implementation, there is no per-open\n * state.  The file memory object also serves as the open file object,\n * saving an allocation.  This has the negative side effect that no per-\n * open state can be retained (such as open flags).\n */\n\nstruct tmpfs_file_s\n{\n  /* First fields must match common TMPFS object layout */\n\n  FAR struct tmpfs_dirent_s *tfo_dirent;\n  struct tmpfs_sem_s tfo_exclsem;\n\n  size_t   tfo_alloc;    /* Allocated size of the file object */\n  uint8_t  tfo_type;     /* See enum tmpfs_objtype_e */\n  uint8_t  tfo_refs;     /* Reference count */\n\n  /* Remaining fields are unique to a directory object */\n\n  uint8_t  tfo_flags;    /* See TFO_FLAG_* definitions */\n  size_t   tfo_size;     /* Valid file size */\n  uint8_t  tfo_data[1];  /* File data starts here */\n};\n")])])]),r("br"),t._v(" "),r("h2",{attrs:{id:"tmpfs-s"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-s"}},[t._v("#")]),t._v(" tmpfs_s")]),t._v(" "),r("p",[t._v("tmpfs的实例，其tfs_root成员指向了tmpfs的根目录。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/* This structure represents one instance of a TMPFS file system */\n\nstruct tmpfs_s\n{\n  /* The root directory */\n\n  FAR struct tmpfs_dirent_s tfs_root;\n  struct tmpfs_sem_s tfs_exclsem;\n};\n")])])]),r("br"),t._v(" "),r("h2",{attrs:{id:"结构体关系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结构体关系"}},[t._v("#")]),t._v(" 结构体关系")]),t._v(" "),r("p",[t._v("以上结构体的之间的关系如下图所示。\n"),r("center",[r("img",{staticStyle:{zoom:"100%"},attrs:{src:n(1309)}})]),t._v(" "),r("br"),r("br")],1),t._v(" "),r("h1",{attrs:{id:"主要内部接口"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主要内部接口"}},[t._v("#")]),t._v(" 主要内部接口")]),t._v(" "),r("p",[t._v("这里根据操作内容将关键的内部接口分为以下四类。\n"),r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"dirent操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dirent操作"}},[t._v("#")]),t._v(" dirent操作")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-add-dirent"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-add-dirent"}},[t._v("#")]),t._v(" tmpfs_add_dirent")]),t._v(" "),r("p",[t._v("上文提到dirent是object加上名称的简化封装版本，而object是目录和文件的抽象，因此文件和目录的新增都会用到tmpfs_add_dirent，其源码如下。"),r("br"),t._v("\n可以看出tmpfs_add_dirent其实只做了一件事，即在对当前目录tdo进行realloc，新增一项tdo_entry，并把新的object（即to）和name赋值给新的tdo_entry。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_add_dirent\n ****************************************************************************/\n\nstatic int tmpfs_add_dirent(FAR struct tmpfs_directory_s **tdo,\n                            FAR struct tmpfs_object_s *to,\n                            FAR const char *name)\n{\n  FAR struct tmpfs_directory_s *oldtdo;\n  FAR struct tmpfs_directory_s *newtdo;\n  FAR struct tmpfs_dirent_s *tde;\n  FAR char *newname;\n  unsigned int nentries;\n  int index;\n\n  /* Copy the name string so that it will persist as long as the\n   * directory entry.\n   */\n\n  newname = strdup(name);\n  if (newname == NULL)\n    {\n      return -ENOMEM;\n    }\n\n  /* Get the new number of entries */\n\n  oldtdo = *tdo;\n  nentries = oldtdo->tdo_nentries + 1;\n\n  /* Reallocate the directory object (if necessary) */\n\n  index = tmpfs_realloc_directory(tdo, nentries);\n  if (index < 0)\n    {\n      kmm_free(newname);\n      return index;\n    }\n\n  /* Save the new object info in the new directory entry */\n\n  newtdo          = *tdo;\n  tde             = &newtdo->tdo_entry[index];\n  tde->tde_object = to;\n  tde->tde_name   = newname;\n\n  /* Add backward link to the directory entry to the object */\n\n  to->to_dirent  = tde;\n  return OK;\n}\n")])])]),r("br"),t._v(" "),r("br"),t._v(" "),r("h3",{attrs:{id:"tmpfs-find-dirent"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-find-dirent"}},[t._v("#")]),t._v(" tmpfs_find_dirent")]),t._v(" "),r("p",[t._v("tmpfs_find_dirent函数用于在指定的目录tdo中查找指定name的dirent，其源码如下，实现较为简单，就是单纯的遍历查找。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_find_dirent\n ****************************************************************************/\n\nstatic int tmpfs_find_dirent(FAR struct tmpfs_directory_s *tdo,\n                             FAR const char *name)\n{\n  int i;\n\n  /* Search the list of directory entries for a match */\n\n  for (i = 0;\n       i < tdo->tdo_nentries &&\n       strcmp(tdo->tdo_entry[i].tde_name, name) != 0;\n       i++);\n\n  /* Return what we found, if anything */\n\n  return i < tdo->tdo_nentries ? i : -ENOENT;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-remove-dirent"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-remove-dirent"}},[t._v("#")]),t._v(" tmpfs_remove_dirent")]),t._v(" "),r("p",[t._v("tmpfs_remove_dirent函数用于从指定的目录tdo中删除名称为name的dirent，其源码如下。这里首先free掉在tmpfs_add_dirent函数中strdup的name，然后判断被删除的dirent是否为最后一个，如果是直接退出，否则把最后一个dirent覆盖到要删除的dirent中从而空出最后一个dirent以备后续使用，避免频繁realloc。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_remove_dirent\n ****************************************************************************/\n\nstatic int tmpfs_remove_dirent(FAR struct tmpfs_directory_s *tdo,\n                               FAR const char *name)\n{\n  int index;\n  int last;\n\n  /* Search the list of directory entries for a match */\n\n  index = tmpfs_find_dirent(tdo, name);\n  if (index < 0)\n    {\n      return index;\n    }\n\n  /* Free the object name */\n\n  if (tdo->tdo_entry[index].tde_name != NULL)\n    {\n      kmm_free(tdo->tdo_entry[index].tde_name);\n    }\n\n  /* Remove by replacing this entry with the final directory entry */\n\n  last = tdo->tdo_nentries - 1;\n  if (index != last)\n    {\n      FAR struct tmpfs_dirent_s *newtde;\n      FAR struct tmpfs_dirent_s *oldtde;\n      FAR struct tmpfs_object_s *to;\n\n      /* Move the directory entry */\n\n      newtde             = &tdo->tdo_entry[index];\n      oldtde             = &tdo->tdo_entry[last];\n      to                 = oldtde->tde_object;\n\n      newtde->tde_object = to;\n      newtde->tde_name   = oldtde->tde_name;\n\n      /* Reset the backward link to the directory entry */\n\n      to->to_dirent      = newtde;\n    }\n\n  /* And decrement the count of directory entries */\n\n  tdo->tdo_nentries = last;\n  return OK;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"object操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object操作"}},[t._v("#")]),t._v(" object操作")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-find-object"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-find-object"}},[t._v("#")]),t._v(" tmpfs_find_object")]),t._v(" "),r("p",[t._v("上文提到object是目录和文件的抽象，因此文件和目录的find都用tmpfs_find_object来实现，其源码如下。"),r("br"),t._v("\n函数虽然在150行左右，但是并不复杂。入参中的relpath为绝对路径，函数从tmpfs的根目录开始查找，具体某一目录下的查找用到了上文提到的tmpfs_find_dirent函数，如果找不到则返回错误码，如果找到则目标object以及其所在的目录上锁，to_refs和tdo_refs都加1。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('/****************************************************************************\n * Name: tmpfs_find_object\n ****************************************************************************/\n\nstatic int tmpfs_find_object(FAR struct tmpfs_s *fs,\n                             FAR const char *relpath,\n                             FAR struct tmpfs_object_s **object,\n                             FAR struct tmpfs_directory_s **parent)\n{\n  FAR struct tmpfs_object_s *to = NULL;\n  FAR struct tmpfs_directory_s *tdo = NULL;\n  FAR struct tmpfs_directory_s *next_tdo;\n  FAR char *segment;\n  FAR char *next_segment;\n  FAR char *tkptr;\n  FAR char *copy;\n  int index;\n  int ret;\n\n  /* Make a copy of the path (so that we can modify it via strtok) */\n\n  copy = strdup(relpath);\n  if (copy == NULL)\n    {\n      return -ENOMEM;\n    }\n\n  /* Traverse the file system for any object with the matching name */\n\n  to       = fs->tfs_root.tde_object;\n  next_tdo = (FAR struct tmpfs_directory_s *)fs->tfs_root.tde_object;\n\n  for (segment =  strtok_r(copy, "/", &tkptr);\n       segment != NULL;\n       segment = next_segment)\n    {\n      /* Get the next segment after the one we are currently working on.\n       * This will be NULL is we are working on the final segment of the\n       * relpath.\n       */\n\n      next_segment = strtok_r(NULL, "/", &tkptr);\n\n      /* Search the next directory. */\n\n      tdo = next_tdo;\n\n      /* Find the TMPFS object with the next segment name in the current\n       * directory.\n       */\n\n      index = tmpfs_find_dirent(tdo, segment);\n      if (index < 0)\n        {\n          /* No object with this name exists in the directory. */\n\n          kmm_free(copy);\n          return index;\n        }\n\n      to = tdo->tdo_entry[index].tde_object;\n\n      /* Is this object another directory? */\n\n      if (to->to_type != TMPFS_DIRECTORY)\n        {\n          /* No.  Was this the final segment in the path? */\n\n          if (next_segment == NULL)\n            {\n              /* Then we can break out of the loop now */\n\n               break;\n            }\n\n          /* No, this was not the final segment of the relpath.\n           * We cannot continue the search if any of the intermediate\n           * segments do no correspond to directories.\n           */\n\n          kmm_free(copy);\n          return -ENOTDIR;\n        }\n\n      /* Search this directory for the next segment.  If we\n       * exit the loop, tdo will still refer to the parent\n       * directory of to.\n       */\n\n      next_tdo = (FAR struct tmpfs_directory_s *)to;\n    }\n\n  /* When we exit this loop (successfully), to will point to the TMPFS\n   * object associated with the terminal segment of the relpath.\n   * Increment the reference count on the located object.\n   */\n\n  /* Free the dup\'ed string */\n\n  kmm_free(copy);\n\n  /* Return what we found */\n\n  if (parent)\n    {\n      if (tdo != NULL)\n        {\n          /* Get exclusive access to the parent and increment the reference\n           * count on the object.\n           */\n\n          ret = tmpfs_lock_directory(tdo);\n          if (ret < 0)\n            {\n              return ret;\n            }\n\n          tdo->tdo_refs++;\n        }\n\n      *parent = tdo;\n    }\n\n  if (object)\n    {\n      if (to != NULL)\n        {\n          /* Get exclusive access to the object and increment the reference\n           * count on the object.\n           */\n\n          ret = tmpfs_lock_object(to);\n          if (ret < 0)\n            {\n              return ret;\n            }\n\n          to->to_refs++;\n        }\n\n      *object = to;\n    }\n\n  return OK;\n}\n')])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"文件操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#文件操作"}},[t._v("#")]),t._v(" 文件操作")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-alloc-file"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-alloc-file"}},[t._v("#")]),t._v(" tmpfs_alloc_file")]),t._v(" "),r("p",[t._v("tmpfs_alloc_file函数用于为新的文件分配空间，其源码如下，实现也非常简单，申请内存，结构体初始化，仅此而已。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_alloc_file\n ****************************************************************************/\n\nstatic FAR struct tmpfs_file_s *tmpfs_alloc_file(void)\n{\n  FAR struct tmpfs_file_s *tfo;\n  size_t allocsize;\n\n  /* Create a new zero length file object */\n\n  allocsize = SIZEOF_TMPFS_FILE(CONFIG_FS_TMPFS_FILE_ALLOCGUARD);\n  tfo = (FAR struct tmpfs_file_s *)kmm_malloc(allocsize);\n  if (tfo == NULL)\n    {\n      return NULL;\n    }\n\n  /* Initialize the new file object.  NOTE that the initial state is\n   * locked with one reference count.\n   */\n\n  tfo->tfo_alloc = allocsize;\n  tfo->tfo_type  = TMPFS_REGULAR;\n  tfo->tfo_refs  = 1;\n  tfo->tfo_flags = 0;\n  tfo->tfo_size  = 0;\n\n  tfo->tfo_exclsem.ts_holder = getpid();\n  tfo->tfo_exclsem.ts_count  = 1;\n  nxsem_init(&tfo->tfo_exclsem.ts_sem, 0, 0);\n\n  return tfo;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-create-file"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-create-file"}},[t._v("#")]),t._v(" tmpfs_create_file")]),t._v(" "),r("p",[t._v("tmpfs_create_file用于创建一个新文件，其源码如下。一开始会先判断是否是在根目录下创建文件，如果是则parent变量为根目录，反正则通过tmpfs_find_directory函数找到待创建文件的上一级目录。然后会通过tmpfs_find_dirent函数查找当前文件是否存在，如果存在则返回错误码退出；如果不存在则调用tmpfs_alloc_file函数为新文件分配空间，调用tmpfs_add_dirent函数在新文件所在的目录下为其分配一个dirent。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_create_file\n ****************************************************************************/\n\nstatic int tmpfs_create_file(FAR struct tmpfs_s *fs,\n                             FAR const char *relpath,\n                             FAR struct tmpfs_file_s **tfo)\n{\n  FAR struct tmpfs_directory_s *parent;\n  FAR struct tmpfs_file_s *newtfo;\n  FAR char *copy;\n  FAR char *name;\n  int ret;\n\n  /* Duplicate the path variable so that we can modify it */\n\n  copy = strdup(relpath);\n  if (copy == NULL)\n    {\n      return -ENOMEM;\n    }\n\n  /* Separate the path into the file name and the path to the parent\n   * directory.\n   */\n\n  name = strrchr(copy, '/');\n  if (name == NULL)\n    {\n      /* No subdirectories... use the root directory */\n\n      name   = copy;\n      parent = (FAR struct tmpfs_directory_s *)fs->tfs_root.tde_object;\n\n      /* Lock the root directory to emulate the behavior of\n       * tmpfs_find_directory()\n       */\n\n      ret = tmpfs_lock_directory(parent);\n      if (ret < 0)\n        {\n          kmm_free(copy);\n          return ret;\n        }\n\n      parent->tdo_refs++;\n    }\n  else\n    {\n      /* Terminate the parent directory path */\n\n      *name++ = '\\0';\n\n      /* Locate the parent directory that should contain this name.\n       * On success, tmpfs_find_directory() will lock the parent\n       * directory and increment the reference count.\n       */\n\n      ret = tmpfs_find_directory(fs, copy, &parent, NULL);\n      if (ret < 0)\n        {\n          goto errout_with_copy;\n        }\n    }\n\n  /* Verify that no object of this name already exists in the directory */\n\n  ret = tmpfs_find_dirent(parent, name);\n  if (ret != -ENOENT)\n    {\n      /* Something with this name already exists in the directory.\n       * OR perhaps some fatal error occurred.\n       */\n\n      if (ret >= 0)\n        {\n          ret = -EEXIST;\n        }\n\n      goto errout_with_parent;\n    }\n\n  /* Allocate an empty file.  The initial state of the file is locked with\n   * one reference count.\n   */\n\n  newtfo = tmpfs_alloc_file();\n  if (newtfo == NULL)\n    {\n      ret = -ENOMEM;\n      goto errout_with_parent;\n    }\n\n  /* Then add the new, empty file to the directory */\n\n  ret = tmpfs_add_dirent(&parent, (FAR struct tmpfs_object_s *)newtfo, name);\n  if (ret < 0)\n    {\n      goto errout_with_file;\n    }\n\n  /* Release the reference and lock on the parent directory */\n\n  parent->tdo_refs--;\n  tmpfs_unlock_directory(parent);\n\n  /* Free the copy of the relpath and return success */\n\n  kmm_free(copy);\n  *tfo = newtfo;\n  return OK;\n\n  /* Error exits */\n\nerrout_with_file:\n  nxsem_destroy(&newtfo->tfo_exclsem.ts_sem);\n  kmm_free(newtfo);\n\nerrout_with_parent:\n  parent->tdo_refs--;\n  tmpfs_unlock_directory(parent);\n\nerrout_with_copy:\n  kmm_free(copy);\n  return ret;\n}\n\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-find-file"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-find-file"}},[t._v("#")]),t._v(" tmpfs_find_file")]),t._v(" "),r("p",[t._v("tmpfs_find_file函数用于从指定的绝对路径中查找目标文件，其源码如下。可以看出本质上就是调用了tmpfs_find_object，同时增加了判断，如果找到的目标文件的属性（to_type）不是文件，则返回错误码退出。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_find_file\n ****************************************************************************/\n\nstatic int tmpfs_find_file(FAR struct tmpfs_s *fs,\n                           FAR const char *relpath,\n                           FAR struct tmpfs_file_s **tfo,\n                           FAR struct tmpfs_directory_s **parent)\n{\n  FAR struct tmpfs_object_s *to;\n  int ret;\n\n  /* Find the object at this path.  If successful, tmpfs_find_object() will\n   * lock both the object and the parent directory and will increment the\n   * reference count on both.\n   */\n\n  ret = tmpfs_find_object(fs, relpath, &to, parent);\n  if (ret >= 0)\n    {\n      /* We found it... but is it a regular file? */\n\n      if (to->to_type != TMPFS_REGULAR)\n        {\n          /* No... unlock the object and its parent and return an error */\n\n          tmpfs_release_lockedobject(to);\n\n          if (parent)\n            {\n              FAR struct tmpfs_directory_s *tdo = *parent;\n\n              tdo->tdo_refs--;\n              tmpfs_unlock_directory(tdo);\n            }\n\n          ret = -EISDIR;\n        }\n\n      /* Return the verified file object */\n\n      *tfo = (FAR struct tmpfs_file_s *)to;\n    }\n\n  return ret;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-realloc-file"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-realloc-file"}},[t._v("#")]),t._v(" tmpfs_realloc_file")]),t._v(" "),r("p",[t._v("tmpfs_realloc_file函数用于扩充当前文件的空间，其源码如下。结构体tmpfs_file_s中的tfo_alloc成员记录了当前file的实际大小，且在文件新创建时会预分配一部分空间，因此当待扩充的大小不超过文件的实际大小时，改变tfo_size的值即可。否则通过kmm_realloc函数进行扩充并完成结构体的更新。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_realloc_file\n ****************************************************************************/\n\nstatic int tmpfs_realloc_file(FAR struct tmpfs_file_s **tfo,\n                              size_t newsize)\n{\n  FAR struct tmpfs_file_s *oldtfo = *tfo;\n  FAR struct tmpfs_file_s *newtfo;\n  size_t objsize;\n  size_t allocsize;\n  size_t delta;\n\n  /* Check if the current allocation is sufficient */\n\n  objsize = SIZEOF_TMPFS_FILE(newsize);\n\n  /* Are we growing or shrinking the object? */\n\n  if (objsize <= oldtfo->tfo_alloc)\n    {\n      /* Shrinking ... Shrink unconditionally if the size is shrinking to\n       * zero.\n       */\n\n      if (newsize > 0)\n        {\n          /* Otherwise, don't realloc unless the object has shrunk by a\n           * lot.\n           */\n\n          delta = oldtfo->tfo_alloc - objsize;\n          if (delta <= CONFIG_FS_TMPFS_FILE_FREEGUARD)\n            {\n              /* Hasn't shrunk enough.. Return doing nothing for now */\n\n              oldtfo->tfo_size = newsize;\n              return OK;\n            }\n        }\n    }\n\n  /* Added some additional amount to the new size to account frequent\n   * reallocations.\n   */\n\n  allocsize = objsize + CONFIG_FS_TMPFS_FILE_ALLOCGUARD;\n\n  /* Realloc the file object */\n\n  newtfo = (FAR struct tmpfs_file_s *)kmm_realloc(oldtfo, allocsize);\n  if (newtfo == NULL)\n    {\n      return -ENOMEM;\n    }\n\n  /* Adjust the reference in the parent directory entry */\n\n  DEBUGASSERT(newtfo->tfo_dirent);\n  newtfo->tfo_dirent->tde_object = (FAR struct tmpfs_object_s *)newtfo;\n\n  /* Return the new address of the reallocated file object */\n\n  newtfo->tfo_alloc = allocsize;\n  newtfo->tfo_size  = newsize;\n  *tfo              = newtfo;\n  return OK;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"目录操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目录操作"}},[t._v("#")]),t._v(" 目录操作")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-alloc-directory"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-alloc-directory"}},[t._v("#")]),t._v(" tmpfs_alloc_directory")]),t._v(" "),r("p",[t._v("tmpfs_alloc_directory函数用于为新的目录分配空间，类似于tmpfs_alloc_file，其实现主要为申请内存，结构体初始化，在此不多赘述。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-create-directory"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-create-directory"}},[t._v("#")]),t._v(" tmpfs_create_directory")]),t._v(" "),r("p",[t._v("tmpfs_create_directory用于创建一个新目录，类似于tmpfs_create_file，在此不多赘述。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-find-directory"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-find-directory"}},[t._v("#")]),t._v(" tmpfs_find_directory")]),t._v(" "),r("p",[t._v("tmpfs_find_directory函数用于从指定的绝对路径中查找目标兖，类似于tmpfs_find_file。本质上也是是调用了tmpfs_find_object，同时增加了判断，如果找到的目标文件的属性（to_type）不是目录，则返回错误码退出。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"tmpfs-realloc-directory"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tmpfs-realloc-directory"}},[t._v("#")]),t._v(" tmpfs_realloc_directory")]),t._v(" "),r("p",[t._v("tmpfs_realloc_directory用于为指定目录tdo扩充一个dirent，其源码如下。不同于tmpfs_realloc_file，这里tmpfs_realloc_directory的入参为期望realloc后dirent的总数。上文提到tmpfs不会立即删去dirent而是将结尾部分预留出来，因此如果当前目录中预留的dirent满足需求，则仅需更新tdo_nentries即可。反之则调用kmm_realloc扩充空间并更新相关结构体。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_realloc_directory\n ****************************************************************************/\n\nstatic int tmpfs_realloc_directory(FAR struct tmpfs_directory_s **tdo,\n                                   unsigned int nentries)\n{\n  FAR struct tmpfs_directory_s *oldtdo = *tdo;\n  FAR struct tmpfs_directory_s *newtdo;\n  size_t objsize;\n  int ret = oldtdo->tdo_nentries;\n\n  /* Get the new object size */\n\n  objsize = SIZEOF_TMPFS_DIRECTORY(nentries);\n  if (objsize <= oldtdo->tdo_alloc)\n    {\n      /* Already big enough.\n       * REVISIT: Missing logic to shrink directory objects.\n       */\n\n      oldtdo->tdo_nentries = nentries;\n      return ret;\n    }\n\n  /* Added some additional amount to the new size to account frequent\n   * reallocations.\n   */\n\n  objsize += CONFIG_FS_TMPFS_DIRECTORY_ALLOCGUARD;\n\n  /* Realloc the directory object */\n\n  newtdo = (FAR struct tmpfs_directory_s *)kmm_realloc(oldtdo, objsize);\n  if (newtdo == NULL)\n    {\n      return -ENOMEM;\n    }\n\n  /* Adjust the reference in the parent directory entry */\n\n  DEBUGASSERT(newtdo->tdo_dirent);\n  newtdo->tdo_dirent->tde_object = (FAR struct tmpfs_object_s *)newtdo;\n\n  /* Return the new address of the reallocated directory object */\n\n  newtdo->tdo_alloc    = objsize;\n  newtdo->tdo_nentries = nentries;\n  *tdo                 = newtdo;\n\n  /* Return the index to the first, newly allocated directory entry */\n\n  return ret;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h1",{attrs:{id:"接口"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),r("p",[t._v("与一般的文件系统一样，tmpfs也提供了一些标准接口作为系统调用的最终实现，这里我们着重讲几个常用的接口。"),r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"bind"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[t._v("#")]),t._v(" bind")]),t._v(" "),r("h3",{attrs:{id:"作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("被调用于初始化阶段，用于创建一个tmpfs根文件系统实例。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("从源码可以看出，bind函数其实就做了两件事：tmpfs_s结构体的内存申请和初始化，涉及的接口在上文已介绍，这里不多赘述。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('/****************************************************************************\n * Name: tmpfs_bind\n ****************************************************************************/\n\nstatic int tmpfs_bind(FAR struct inode *blkdriver, FAR const void *data,\n                      FAR void **handle)\n{\n  FAR struct tmpfs_directory_s *tdo;\n  FAR struct tmpfs_s *fs;\n\n  finfo("blkdriver: %p data: %p handle: %p\\n", blkdriver, data, handle);\n  DEBUGASSERT(blkdriver == NULL && handle != NULL);\n\n  /* Create an instance of the tmpfs file system */\n\n  fs = (FAR struct tmpfs_s *)kmm_zalloc(sizeof(struct tmpfs_s));\n  if (fs == NULL)\n    {\n      return -ENOMEM;\n    }\n\n  /* Create a root file system.  This is like a single directory entry in\n   * the file system structure.\n   */\n\n  tdo = tmpfs_alloc_directory();\n  if (tdo == NULL)\n    {\n      kmm_free(fs);\n      return -ENOMEM;\n    }\n\n  fs->tfs_root.tde_object = (FAR struct tmpfs_object_s *)tdo;\n  fs->tfs_root.tde_name   = "";\n\n  /* Set up the backward link (to support reallocation) */\n\n  tdo->tdo_dirent         = &fs->tfs_root;\n\n  /* Initialize the file system state */\n\n  fs->tfs_exclsem.ts_holder = TMPFS_NO_HOLDER;\n  fs->tfs_exclsem.ts_count  = 0;\n  nxsem_init(&fs->tfs_exclsem.ts_sem, 0, 1);\n\n  /* Return the new file system handle */\n\n  *handle = (FAR void *)fs;\n  return OK;\n}\n')])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"unbind"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unbind"}},[t._v("#")]),t._v(" unbind")]),t._v(" "),r("h3",{attrs:{id:"作用-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-2"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("释放整个tmpfs文件系统\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-2"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("unbind的核心为tmpfs_foreach函数，该函数通过层层遍历逐级释放掉tmpfs中的内容，最后tmpfs释放掉根文件系统。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('/****************************************************************************\n * Name: tmpfs_unbind\n ****************************************************************************/\n\nstatic int tmpfs_unbind(FAR void *handle, FAR struct inode **blkdriver,\n                        unsigned int flags)\n{\n  FAR struct tmpfs_s *fs = (FAR struct tmpfs_s *)handle;\n  FAR struct tmpfs_directory_s *tdo;\n  int ret;\n\n  finfo("handle: %p blkdriver: %p flags: %02x\\n",\n        handle, blkdriver, flags);\n  DEBUGASSERT(fs != NULL && fs->tfs_root.tde_object != NULL);\n\n  /* Lock the file system */\n\n  ret = tmpfs_lock(fs);\n  if (ret < 0)\n    {\n      return ret;\n    }\n\n  /* Traverse all directory entries (recursively), freeing all resources. */\n\n  tdo = (FAR struct tmpfs_directory_s *)fs->tfs_root.tde_object;\n  ret = tmpfs_foreach(tdo, tmpfs_free_callout, NULL);\n\n  /* Now we can destroy the root file system and the file system itself. */\n\n  nxsem_destroy(&tdo->tdo_exclsem.ts_sem);\n  kmm_free(tdo);\n\n  nxsem_destroy(&fs->tfs_exclsem.ts_sem);\n  kmm_free(fs);\n  return ret;\n}\n')])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"open"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#open"}},[t._v("#")]),t._v(" open")]),t._v(" "),r("h3",{attrs:{id:"作用-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-3"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用open系统调用，用于打开一个文件。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-3"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("代码虽150行左右，但是内部接口我们之前已有介绍，因此此时再看并不复杂。首先是通过tmpfs_find_file函数查找文件，如果文件确实不存在，则根据用户态传进来的flag来决定是tmpfs_create_file创建一个新文件还是报错退出；如果文件存在，则根据用户态传进来的flag来决定是返回EEXIST错误码退出还是将文件清零。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_open\n ****************************************************************************/\n\nstatic int tmpfs_open(FAR struct file *filep, FAR const char *relpath,\n                      int oflags, mode_t mode)\n{\n  FAR struct inode *inode;\n  FAR struct tmpfs_s *fs;\n  FAR struct tmpfs_file_s *tfo;\n  off_t offset;\n  int ret;\n\n  finfo(\"filep: %p\\n\", filep);\n  DEBUGASSERT(filep->f_priv == NULL && filep->f_inode != NULL);\n\n  /* Get the mountpoint inode reference from the file structure and the\n   * mountpoint private data from the inode structure\n   */\n\n  inode = filep->f_inode;\n  fs    = inode->i_private;\n\n  DEBUGASSERT(fs != NULL && fs->tfs_root.tde_object != NULL);\n\n  /* Get exclusive access to the file system */\n\n  ret = tmpfs_lock(fs);\n  if (ret < 0)\n    {\n      return ret;\n    }\n\n  /* Skip over any leading directory separators (shouldn't be any) */\n\n  for (; *relpath == '/'; relpath++);\n\n  /* Find the file object associated with this relative path.\n   * If successful, this action will lock both the parent directory and\n   * the file object, adding one to the reference count of both.\n   * In the event that -ENOENT, there will still be a reference and\n   * lock on the returned directory.\n   */\n\n  ret = tmpfs_find_file(fs, relpath, &tfo, NULL);\n  if (ret >= 0)\n    {\n      /* The file exists.  We hold the lock and one reference count\n       * on the file object.\n       *\n       * It would be an error if we are asked to create it exclusively\n       */\n\n      if ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n        {\n          /* Already exists -- can't create it exclusively */\n\n          ret = -EEXIST;\n          goto errout_with_filelock;\n        }\n\n      /* Check if the caller has sufficient privileges to open the file.\n       * REVISIT: No file protection implemented\n       */\n\n      /* If O_TRUNC is specified and the file is opened for writing,\n       * then truncate the file.  This operation requires that the file is\n       * writeable, but we have already checked that. O_TRUNC without write\n       * access is ignored.\n       */\n\n      if ((oflags & (O_TRUNC | O_WRONLY)) == (O_TRUNC | O_WRONLY))\n        {\n          /* Truncate the file to zero length (if it is not already\n           * zero length)\n           */\n\n          if (tfo->tfo_size > 0)\n            {\n              ret = tmpfs_realloc_file(&tfo, 0);\n              if (ret < 0)\n                {\n                  goto errout_with_filelock;\n                }\n            }\n        }\n    }\n\n  /* ENOENT would be returned by tmpfs_find_file() if the full directory\n   * path was found, but the file was not found in the final directory.\n   */\n\n  else if (ret == -ENOENT)\n    {\n      /* The file does not exist.  Were we asked to create it? */\n\n      if ((oflags & O_CREAT) == 0)\n        {\n          /* No.. then we fail with -ENOENT */\n\n          ret = -ENOENT;\n          goto errout_with_fslock;\n        }\n\n      /* Yes.. create the file object.  There will be a reference and a lock\n       * on the new file object.\n       */\n\n      ret = tmpfs_create_file(fs, relpath, &tfo);\n      if (ret < 0)\n        {\n          goto errout_with_fslock;\n        }\n    }\n\n  /* Some other error occurred */\n\n  else\n    {\n      goto errout_with_fslock;\n    }\n\n  /* Save the struct tmpfs_file_s instance as the file private data */\n\n  filep->f_priv = tfo;\n\n  /* In write/append mode, we need to set the file pointer to the end of the\n   * file.\n   */\n\n  offset = 0;\n  if ((oflags & (O_APPEND | O_WRONLY)) == (O_APPEND | O_WRONLY))\n    {\n      offset = tfo->tfo_size;\n    }\n\n  filep->f_pos = offset;\n\n  /* Unlock the file file object, but retain the reference count */\n\n  tmpfs_unlock_file(tfo);\n  tmpfs_unlock(fs);\n  return OK;\n\n  /* Error exits */\n\nerrout_with_filelock:\n  tmpfs_release_lockedfile(tfo);\n\nerrout_with_fslock:\n  tmpfs_unlock(fs);\n  return ret;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"close"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#close"}},[t._v("#")]),t._v(" close")]),t._v(" "),r("h3",{attrs:{id:"作用-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-4"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用close系统调用，用于关闭一个文件。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-4"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("close函数的实现也非常简单，其核心其实就是对tfo_refs成员的操作，源码如下，不多赘述。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('/****************************************************************************\n * Name: tmpfs_close\n ****************************************************************************/\n\nstatic int tmpfs_close(FAR struct file *filep)\n{\n  FAR struct tmpfs_file_s *tfo;\n  int ret;\n\n  finfo("filep: %p\\n", filep);\n  DEBUGASSERT(filep->f_priv != NULL && filep->f_inode != NULL);\n\n  /* Recover our private data from the struct file instance */\n\n  tfo = filep->f_priv;\n\n  /* Get exclusive access to the file */\n\n  ret = tmpfs_lock_file(tfo);\n  if (ret < 0)\n    {\n      return ret;\n    }\n\n  /* Decrement the reference count on the file */\n\n  DEBUGASSERT(tfo->tfo_refs > 0);\n  if (tfo->tfo_refs > 0)\n    {\n      tfo->tfo_refs--;\n    }\n\n  filep->f_priv = NULL;\n\n  /* If the reference count decremented to zero and the file has been\n   * unlinked, then free the file allocation now.\n   */\n\n  if (tfo->tfo_refs == 0 && (tfo->tfo_flags & TFO_FLAG_UNLINKED) != 0)\n    {\n      /* Free the file object while we hold the lock?  Weird but this\n       * should be safe because the object is unlinked and could not\n       * have any other references.\n       */\n\n      kmm_free(tfo);\n      return OK;\n    }\n\n  /* Release the lock on the file */\n\n  tmpfs_unlock_file(tfo);\n  return OK;\n}\n')])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"read"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#read"}},[t._v("#")]),t._v(" read")]),t._v(" "),r("h3",{attrs:{id:"作用-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-5"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用read系统调用，用于从文件中读取内容到指定buf。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-5"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("read函数的源码如下，核心是调用memcpy将文件指定位置的内容复制到用户提供的buf中。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('/****************************************************************************\n * Name: tmpfs_read\n ****************************************************************************/\n\nstatic ssize_t tmpfs_read(FAR struct file *filep, FAR char *buffer,\n                          size_t buflen)\n{\n  FAR struct tmpfs_file_s *tfo;\n  ssize_t nread;\n  off_t startpos;\n  off_t endpos;\n  int ret;\n\n  finfo("filep: %p buffer: %p buflen: %lu\\n",\n        filep, buffer, (unsigned long)buflen);\n  DEBUGASSERT(filep->f_priv != NULL && filep->f_inode != NULL);\n\n  /* Recover our private data from the struct file instance */\n\n  tfo = filep->f_priv;\n\n  /* Get exclusive access to the file */\n\n  ret = tmpfs_lock_file(tfo);\n  if (ret < 0)\n    {\n      return ret;\n    }\n\n  /* Handle attempts to read beyond the end of the file. */\n\n  startpos = filep->f_pos;\n  nread    = buflen;\n  endpos   = startpos + buflen;\n\n  if (endpos > tfo->tfo_size)\n    {\n      endpos = tfo->tfo_size;\n      nread  = endpos - startpos;\n    }\n\n  /* Copy data from the memory object to the user buffer */\n\n  memcpy(buffer, &tfo->tfo_data[startpos], nread);\n  filep->f_pos += nread;\n\n  /* Release the lock on the file */\n\n  tmpfs_unlock_file(tfo);\n  return nread;\n}\n')])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"write"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#write"}},[t._v("#")]),t._v(" write")]),t._v(" "),r("h3",{attrs:{id:"作用-6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-6"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用write系统调用，用于把指定buf中的内容写入文件。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-6"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("write函数的源码如下，核心是调用memcpy将用户提供的buf中的内容复制到文件指定位置。如果文件空间不足则会先调用tmpfs_realloc_file函数进行扩容。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('/****************************************************************************\n * Name: tmpfs_write\n ****************************************************************************/\n\nstatic ssize_t tmpfs_write(FAR struct file *filep, FAR const char *buffer,\n                           size_t buflen)\n{\n  FAR struct tmpfs_file_s *tfo;\n  ssize_t nwritten;\n  off_t startpos;\n  off_t endpos;\n  int ret;\n\n  finfo("filep: %p buffer: %p buflen: %lu\\n",\n        filep, buffer, (unsigned long)buflen);\n  DEBUGASSERT(filep->f_priv != NULL && filep->f_inode != NULL);\n\n  /* Recover our private data from the struct file instance */\n\n  tfo = filep->f_priv;\n\n  /* Get exclusive access to the file */\n\n  ret = tmpfs_lock_file(tfo);\n  if (ret < 0)\n    {\n      return ret;\n    }\n\n  /* Handle attempts to write beyond the end of the file */\n\n  startpos = filep->f_pos;\n  nwritten = buflen;\n  endpos   = startpos + buflen;\n\n  if (endpos > tfo->tfo_size)\n    {\n      /* Reallocate the file to handle the write past the end of the file. */\n\n      ret = tmpfs_realloc_file(&tfo, (size_t)endpos);\n      if (ret < 0)\n        {\n          goto errout_with_lock;\n        }\n\n      filep->f_priv = tfo;\n    }\n\n  /* Copy data from the memory object to the user buffer */\n\n  memcpy(&tfo->tfo_data[startpos], buffer, nwritten);\n  filep->f_pos += nwritten;\n\n  /* Release the lock on the file */\n\n  tmpfs_unlock_file(tfo);\n  return nwritten;\n\nerrout_with_lock:\n  tmpfs_unlock_file(tfo);\n  return (ssize_t)ret;\n}\n')])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"seek"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#seek"}},[t._v("#")]),t._v(" seek")]),t._v(" "),r("h3",{attrs:{id:"作用-7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-7"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用lseek系统调用，用于获取或移动文件指针的位置。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-7"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("tmpfs中用f_pos成员表示当前文件指针的位置，上文中也可以看到open时f_pos根据用户需要会清理或追加到文件尾部。tmpfs的seek源码如下，实现较为简单， 这里不多赘述。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('/****************************************************************************\n * Name: tmpfs_seek\n ****************************************************************************/\n\nstatic off_t tmpfs_seek(FAR struct file *filep, off_t offset, int whence)\n{\n  FAR struct tmpfs_file_s *tfo;\n  off_t position;\n\n  finfo("filep: %p\\n", filep);\n  DEBUGASSERT(filep->f_priv != NULL && filep->f_inode != NULL);\n\n  /* Recover our private data from the struct file instance */\n\n  tfo = filep->f_priv;\n\n  /* Map the offset according to the whence option */\n\n  switch (whence)\n    {\n      case SEEK_SET: /* The offset is set to offset bytes. */\n          position = offset;\n          break;\n\n      case SEEK_CUR: /* The offset is set to its current location plus\n                      * offset bytes. */\n          position = offset + filep->f_pos;\n          break;\n\n      case SEEK_END: /* The offset is set to the size of the file plus\n                      * offset bytes. */\n          position = offset + tfo->tfo_size;\n          break;\n\n      default:\n          return -EINVAL;\n    }\n\n  /* Attempts to set the position beyond the end of file will\n   * work if the file is open for write access.\n   *\n   * REVISIT: This simple implementation has no per-open storage that\n   * would be needed to retain the open flags.\n   */\n\n#if 0\n  if (position > tfo->tfo_size && (tfo->tfo_oflags & O_WROK) == 0)\n    {\n      /* Otherwise, the position is limited to the file size */\n\n      position = tfo->tfo_size;\n    }\n#endif\n\n  /* Save the new file position */\n\n  filep->f_pos = position;\n  return position;\n}\n')])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"mkdir"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mkdir"}},[t._v("#")]),t._v(" mkdir")]),t._v(" "),r("h3",{attrs:{id:"作用-8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-8"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用mkdir系统调用，用于创建一个新目录。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-8"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("write函数的源码如下，核心是调用tmpfs_create_directory来创建目录，具体实现上文已介绍，这里不多赘述。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('/****************************************************************************\n * Name: tmpfs_mkdir\n ****************************************************************************/\n\nstatic int tmpfs_mkdir(FAR struct inode *mountpt, FAR const char *relpath,\n                       mode_t mode)\n{\n  FAR struct tmpfs_s *fs;\n  int ret;\n\n  finfo("mountpt: %p relpath: %s mode: %04x\\n", mountpt, relpath, mode);\n  DEBUGASSERT(mountpt != NULL && relpath != NULL);\n\n  /* Get the file system structure from the inode reference. */\n\n  fs = mountpt->i_private;\n  DEBUGASSERT(fs != NULL && fs->tfs_root.tde_object != NULL);\n\n  /* Get exclusive access to the file system */\n\n  ret = tmpfs_lock(fs);\n  if (ret < 0)\n    {\n      return ret;\n    }\n\n  /* Create the directory. */\n\n  ret = tmpfs_create_directory(fs, relpath, NULL);\n  tmpfs_unlock(fs);\n  return ret;\n}\n')])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"opendir"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#opendir"}},[t._v("#")]),t._v(" opendir")]),t._v(" "),r("h3",{attrs:{id:"作用-9"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-9"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用opendir，用于打开一个目录。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-9"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-9"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("opendir函数的源码如下，核心是调用tmpfs_find_directory找到指定的目录，并将目录结构体返回给调用opendir的上一级，并经过处理返回给用户。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_opendir\n ****************************************************************************/\n\nstatic int tmpfs_opendir(FAR struct inode *mountpt, FAR const char *relpath,\n                         FAR struct fs_dirent_s *dir)\n{\n  FAR struct tmpfs_s *fs;\n  FAR struct tmpfs_directory_s *tdo;\n  int ret;\n\n  finfo(\"mountpt: %p relpath: %s dir: %p\\n\",\n        mountpt, relpath, dir);\n  DEBUGASSERT(mountpt != NULL && relpath != NULL && dir != NULL);\n\n  /* Get the mountpoint private data from the inode structure */\n\n  fs = mountpt->i_private;\n  DEBUGASSERT(fs != NULL && fs->tfs_root.tde_object != NULL);\n\n  /* Get exclusive access to the file system */\n\n  ret = tmpfs_lock(fs);\n  if (ret < 0)\n    {\n      return ret;\n    }\n\n  /* Skip over any leading directory separators (shouldn't be any) */\n\n  for (; *relpath == '/'; relpath++);\n\n  /* Find the directory object associated with this relative path.\n   * If successful, this action will lock both the parent directory and\n   * the file object, adding one to the reference count of both.\n   * In the event that -ENOENT, there will still be a reference and\n   * lock on the returned directory.\n   */\n\n  ret = tmpfs_find_directory(fs, relpath, &tdo, NULL);\n  if (ret >= 0)\n    {\n      dir->u.tmpfs.tf_tdo   = tdo;\n      dir->u.tmpfs.tf_index = tdo->tdo_nentries;\n\n      tmpfs_unlock_directory(tdo);\n    }\n\n  /* Release the lock on the file system and return the result */\n\n  tmpfs_unlock(fs);\n  return ret;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"closedir"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#closedir"}},[t._v("#")]),t._v(" closedir")]),t._v(" "),r("h3",{attrs:{id:"作用-10"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-10"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用closedir，用于关闭通过opendir打开的目录。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-10"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-10"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("closedir函数的源码如下，核心就是将tdo_refs自减，该成员在opendir的使用由于调用了tmpfs_find_object发生了自增。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('/****************************************************************************\n * Name: tmpfs_closedir\n ****************************************************************************/\n\nstatic int tmpfs_closedir(FAR struct inode *mountpt,\n                          FAR struct fs_dirent_s *dir)\n{\n  FAR struct tmpfs_directory_s *tdo;\n\n  finfo("mountpt: %p dir: %p\\n",  mountpt, dir);\n  DEBUGASSERT(mountpt != NULL && dir != NULL);\n\n  /* Get the directory structure from the dir argument */\n\n  tdo = dir->u.tmpfs.tf_tdo;\n  DEBUGASSERT(tdo != NULL);\n\n  /* Decrement the reference count on the directory object */\n\n  tmpfs_lock_directory(tdo);\n  tdo->tdo_refs--;\n  tmpfs_unlock_directory(tdo);\n  return OK;\n}\n')])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"readdir"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#readdir"}},[t._v("#")]),t._v(" readdir")]),t._v(" "),r("h3",{attrs:{id:"作用-11"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-11"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用readdir，用于读取opendir打开的目录。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-11"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-11"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("readdir的源码如下，其核心是使用opendir时获取的tf_index从后往前访问目标目录下的dirent，然后index自减。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('/****************************************************************************\n * Name: tmpfs_readdir\n ****************************************************************************/\n\nstatic int tmpfs_readdir(FAR struct inode *mountpt,\n                         FAR struct fs_dirent_s *dir)\n{\n  FAR struct tmpfs_directory_s *tdo;\n  unsigned int index;\n  int ret;\n\n  finfo("mountpt: %p dir: %p\\n",  mountpt, dir);\n  DEBUGASSERT(mountpt != NULL && dir != NULL);\n\n  /* Get the directory structure from the dir argument and lock it */\n\n  tdo = dir->u.tmpfs.tf_tdo;\n  DEBUGASSERT(tdo != NULL);\n\n  tmpfs_lock_directory(tdo);\n\n  /* Have we reached the end of the directory? */\n\n  index = dir->u.tmpfs.tf_index;\n  if (index-- == 0)\n    {\n      /* We signal the end of the directory by returning the special error:\n       * -ENOENT\n       */\n\n      finfo("End of directory\\n");\n      ret = -ENOENT;\n    }\n  else\n    {\n      FAR struct tmpfs_dirent_s *tde;\n      FAR struct tmpfs_object_s *to;\n\n      /* Does this entry refer to a file or a directory object? */\n\n      tde = &tdo->tdo_entry[index];\n      to  = tde->tde_object;\n      DEBUGASSERT(to != NULL);\n\n      if (to->to_type == TMPFS_DIRECTORY)\n        {\n          /* A directory */\n\n           dir->fd_dir.d_type = DTYPE_DIRECTORY;\n        }\n      else /* to->to_type == TMPFS_REGULAR) */\n        {\n          /* A regular file */\n\n           dir->fd_dir.d_type = DTYPE_FILE;\n        }\n\n      /* Copy the entry name */\n\n      strncpy(dir->fd_dir.d_name, tde->tde_name, NAME_MAX);\n\n      /* Save the index for next time */\n\n      dir->u.tmpfs.tf_index = index;\n      ret = OK;\n    }\n\n  tmpfs_unlock_directory(tdo);\n  return ret;\n}\n')])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"unlink"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unlink"}},[t._v("#")]),t._v(" unlink")]),t._v(" "),r("h3",{attrs:{id:"作用-12"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-12"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用unlink系统调用，用于删除一个文件。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-12"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-12"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("unlink函数源码如下，首先通过tmpfs_find_file找到目标文件以及其所在的目录，然后通过tmpfs_remove_dirent函数将目标文件的dirent从所在目录中删去。随后会判断文件的tfo_refs值，如果小于等于1，则会调用kmm_free释放目标文件占用的内存。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_unlink\n ****************************************************************************/\n\nstatic int tmpfs_unlink(FAR struct inode *mountpt, FAR const char *relpath)\n{\n  FAR struct tmpfs_s *fs;\n  FAR struct tmpfs_directory_s *tdo;\n  FAR struct tmpfs_file_s *tfo = NULL;\n  FAR const char *name;\n  int ret;\n\n  finfo(\"mountpt: %p relpath: %s\\n\", mountpt, relpath);\n  DEBUGASSERT(mountpt != NULL && relpath != NULL);\n\n  /* Get the file system structure from the inode reference. */\n\n  fs = mountpt->i_private;\n  DEBUGASSERT(fs != NULL && fs->tfs_root.tde_object != NULL);\n\n  /* Get exclusive access to the file system */\n\n  ret = tmpfs_lock(fs);\n  if (ret < 0)\n    {\n      return ret;\n    }\n\n  /* Find the file object and parent directory associated with this relative\n   * path.  If successful, tmpfs_find_file will lock both the file object\n   * and the parent directory and take one reference count on each.\n   */\n\n  ret = tmpfs_find_file(fs, relpath, &tfo, &tdo);\n  if (ret < 0)\n    {\n      goto errout_with_lock;\n    }\n\n  DEBUGASSERT(tfo != NULL);\n\n  /* Get the file name from the relative path */\n\n  name = strrchr(relpath, '/');\n  if (name != NULL)\n    {\n      /* Skip over the file '/' character */\n\n      name++;\n    }\n  else\n    {\n      /* The name must lie in the root directory */\n\n      name = relpath;\n    }\n\n  /* Remove the file from parent directory */\n\n  ret = tmpfs_remove_dirent(tdo, name);\n  if (ret < 0)\n    {\n      goto errout_with_objects;\n    }\n\n  /* If the reference count is not one, then just mark the file as\n   * unlinked\n   */\n\n  if (tfo->tfo_refs > 1)\n    {\n      /* Make the file object as unlinked */\n\n      tfo->tfo_flags |= TFO_FLAG_UNLINKED;\n\n      /* Release the reference count on the file object */\n\n      tfo->tfo_refs--;\n      tmpfs_unlock_file(tfo);\n    }\n\n  /* Otherwise we can free the object now */\n\n  else\n    {\n      nxsem_destroy(&tfo->tfo_exclsem.ts_sem);\n      kmm_free(tfo);\n    }\n\n  /* Release the reference and lock on the parent directory */\n\n  tdo->tdo_refs--;\n  tmpfs_unlock_directory(tdo);\n  tmpfs_unlock(fs);\n\n  return OK;\n\nerrout_with_objects:\n  tmpfs_release_lockedfile(tfo);\n\n  tdo->tdo_refs--;\n  tmpfs_unlock_directory(tdo);\n\nerrout_with_lock:\n  tmpfs_unlock(fs);\n  return ret;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"rmdir"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rmdir"}},[t._v("#")]),t._v(" rmdir")]),t._v(" "),r("h3",{attrs:{id:"作用-13"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-13"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用rmdir系统调用，用于删除一个目录。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-13"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-13"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("rmdir的源码如下，类似于unlink，先通过tmpfs_find_directory查找目标目录，不同的是如果目标目录下还有文件或目标目录被其它进程打开，会直接返回错误码退出。其余过程与unlink基本一致。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_rmdir\n ****************************************************************************/\n\nstatic int tmpfs_rmdir(FAR struct inode *mountpt, FAR const char *relpath)\n{\n  FAR struct tmpfs_s *fs;\n  FAR struct tmpfs_directory_s *parent;\n  FAR struct tmpfs_directory_s *tdo;\n  FAR const char *name;\n  int ret;\n\n  finfo(\"mountpt: %p relpath: %s\\n\", mountpt, relpath);\n  DEBUGASSERT(mountpt != NULL && relpath != NULL);\n\n  /* Get the file system structure from the inode reference. */\n\n  fs = mountpt->i_private;\n  DEBUGASSERT(fs != NULL && fs->tfs_root.tde_object != NULL);\n\n  /* Get exclusive access to the file system */\n\n  ret = tmpfs_lock(fs);\n  if (ret < 0)\n    {\n      return ret;\n    }\n\n  /* Find the directory object and parent directory associated with this\n   * relative path.  If successful, tmpfs_find_file will lock both the\n   * directory object and the parent directory and take one reference count\n   * on each.\n   */\n\n  ret = tmpfs_find_directory(fs, relpath, &tdo, &parent);\n  if (ret < 0)\n    {\n      goto errout_with_lock;\n    }\n\n  /* Is the directory empty?  We cannot remove directories that still\n   * contain references to file system objects.  No can we remove the\n   * directory if there are outstanding references on it (other than\n   * our reference).\n   */\n\n  if (tdo->tdo_nentries > 0 || tdo->tdo_refs > 1)\n    {\n      ret = -EBUSY;\n      goto errout_with_objects;\n    }\n\n  /* Get the directory name from the relative path */\n\n  name = strrchr(relpath, '/');\n  if (name != NULL)\n    {\n      /* Skip over the fidirectoryle '/' character */\n\n      name++;\n    }\n  else\n    {\n      /* The name must lie in the root directory */\n\n      name = relpath;\n    }\n\n  /* Remove the directory from parent directory */\n\n  ret = tmpfs_remove_dirent(parent, name);\n  if (ret < 0)\n    {\n      goto errout_with_objects;\n    }\n\n  /* Free the directory object */\n\n  nxsem_destroy(&tdo->tdo_exclsem.ts_sem);\n  kmm_free(tdo);\n\n  /* Release the reference and lock on the parent directory */\n\n  parent->tdo_refs--;\n  tmpfs_unlock_directory(parent);\n  tmpfs_unlock(fs);\n\n  return OK;\n\nerrout_with_objects:\n  tdo->tdo_refs--;\n  tmpfs_unlock_directory(tdo);\n\n  parent->tdo_refs--;\n  tmpfs_unlock_directory(parent);\n\nerrout_with_lock:\n  tmpfs_unlock(fs);\n  return ret;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h2",{attrs:{id:"rename"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rename"}},[t._v("#")]),t._v(" rename")]),t._v(" "),r("h3",{attrs:{id:"作用-14"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用-14"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),r("p",[t._v("对应于用户态使用rename系统调用，用于重命名文件或目录。\n"),r("br"),r("br")]),t._v(" "),r("h3",{attrs:{id:"源码分析-14"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源码分析-14"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),r("p",[t._v("rename源码如下，tmpfs_rename传入的oldrelpath和newrelpath均已经处理为绝对路径。首先先判断newrelpath是否在根目录，若是则父目录为根文件系统，否则通过tmpfs_find_directory函数查找新文件名对应的新父目录，找到后通过tmpfs_find_dirent函数在新父目录中查找新文件名是否已经有对应的文件存在，如果是则返回错误码，否则继续执行。接下来会查找旧文件名对应的父目录以及文件本身的结构体，并将旧文件名对应的dirent从旧父目录中删去，然后将新文件名对应的dirent与文件结构体关联并添加到新的父目录，如此便rename完成。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/****************************************************************************\n * Name: tmpfs_rename\n ****************************************************************************/\n\nstatic int tmpfs_rename(FAR struct inode *mountpt,\n                        FAR const char *oldrelpath,\n                        FAR const char *newrelpath)\n{\n  FAR struct tmpfs_directory_s *oldparent;\n  FAR struct tmpfs_directory_s *newparent;\n  FAR struct tmpfs_object_s *to;\n  FAR struct tmpfs_s *fs;\n  FAR const char *oldname;\n  FAR char *newname;\n  FAR char *copy;\n  int ret;\n\n  finfo(\"mountpt: %p oldrelpath: %s newrelpath: %s\\n\",\n        mountpt, oldrelpath, newrelpath);\n  DEBUGASSERT(mountpt != NULL && oldrelpath != NULL && newrelpath != NULL);\n\n  /* Get the file system structure from the inode reference. */\n\n  fs = mountpt->i_private;\n  DEBUGASSERT(fs != NULL && fs->tfs_root.tde_object != NULL);\n\n  /* Duplicate the newpath variable so that we can modify it */\n\n  copy = strdup(newrelpath);\n  if (copy == NULL)\n    {\n      return -ENOMEM;\n    }\n\n  /* Get exclusive access to the file system */\n\n  ret = tmpfs_lock(fs);\n  if (ret < 0)\n    {\n      kmm_free(copy);\n      return ret;\n    }\n\n  /* Separate the new path into the new file name and the path to the new\n   * parent directory.\n   */\n\n  newname = strrchr(copy, '/');\n  if (newname == NULL)\n    {\n      /* No subdirectories... use the root directory */\n\n      newname   = copy;\n      newparent = (FAR struct tmpfs_directory_s *)fs->tfs_root.tde_object;\n\n      tmpfs_lock_directory(newparent);\n      newparent->tdo_refs++;\n    }\n  else\n    {\n      /* Terminate the parent directory path */\n\n      *newname++ = '\\0';\n\n      /* Locate the parent directory that should contain this name.\n       * On success, tmpfs_find_directory() will lockthe parent\n       * directory and increment the reference count.\n       */\n\n      ret = tmpfs_find_directory(fs, copy, &newparent, NULL);\n      if (ret < 0)\n        {\n          goto errout_with_lock;\n        }\n    }\n\n  /* Verify that no object of this name already exists in the destination\n   * directory.\n   */\n\n  ret = tmpfs_find_dirent(newparent, newname);\n  if (ret != -ENOENT)\n    {\n      /* Something with this name already exists in the directory.\n       * OR perhaps some fatal error occurred.\n       */\n\n      if (ret >= 0)\n        {\n          ret = -EEXIST;\n        }\n\n      goto errout_with_newparent;\n    }\n\n  /* Find the old object at oldpath.  If successful, tmpfs_find_object()\n   * will lock both the object and the parent directory and will increment\n   * the reference count on both.\n   */\n\n  ret = tmpfs_find_object(fs, oldrelpath, &to, &oldparent);\n  if (ret < 0)\n    {\n      goto errout_with_newparent;\n    }\n\n  /* Get the old file name from the relative path */\n\n  oldname = strrchr(oldrelpath, '/');\n  if (oldname != NULL)\n    {\n      /* Skip over the file '/' character */\n\n      oldname++;\n    }\n  else\n    {\n      /* The name must lie in the root directory */\n\n      oldname = oldrelpath;\n    }\n\n  /* Remove the entry from the parent directory */\n\n  ret = tmpfs_remove_dirent(oldparent, oldname);\n  if (ret < 0)\n    {\n      goto errout_with_oldparent;\n    }\n\n  /* Add an entry to the new parent directory. */\n\n  ret = tmpfs_add_dirent(&newparent, to, newname);\n\nerrout_with_oldparent:\n  oldparent->tdo_refs--;\n  tmpfs_unlock_directory(oldparent);\n\n  tmpfs_release_lockedobject(to);\n\nerrout_with_newparent:\n  newparent->tdo_refs--;\n  tmpfs_unlock_directory(newparent);\n\nerrout_with_lock:\n  tmpfs_unlock(fs);\n  kmm_free(copy);\n  return ret;\n}\n")])])]),r("p",[r("br"),r("br")]),t._v(" "),r("h1",{attrs:{id:"小结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),r("p",[t._v("本文结合nuttx源码介绍了tmpfs的基本数据结构以及常用的几个系统调用实现。nuttx tmpfs的内容虽然并不复杂但是功能基本完备，并且对于后续理解linux中复杂的文件系统具有一定的参考价值。"),r("br"),t._v(" "),r("br")]),t._v(" "),r("h1",{attrs:{id:"文章推荐"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#文章推荐"}},[t._v("#")]),t._v(" 文章推荐")]),t._v(" "),r("p",[t._v("glibc malloc系列文章："),r("br"),t._v("\n    原理简析："),r("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc+malloc%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/glibc+malloc%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90.html "),r("br"),t._v("\n    数据结构："),r("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc+malloc%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90.html "),r("br"),t._v("\n    malloc："),r("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc+malloc%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90(%E4%BA%8C).html "),r("br"),t._v("\n    free："),r("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc+malloc%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90(%E4%B8%89).html "),r("br"),t._v(" "),r("br")]),t._v(" "),r("p",[t._v("glibc问题定位与分析系列文章："),r("br"),t._v("\n    memcpy 1k字节x86_64虚拟机性能下降分析："),r("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/memcpy_1k%E5%AD%97%E8%8A%82x86_64%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90.html "),r("br"),t._v("\n    调用栈问题分析："),r("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D--%E6%8E%A8%E6%A0%88%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html "),r("br"),t._v(" "),r("br")]),t._v(" "),r("p",[t._v("    glibc locale使用简析："),r("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc%20locale%E4%BD%BF%E7%94%A8%E7%AE%80%E6%9E%90/glibc+locale%E4%BD%BF%E7%94%A8%E7%AE%80%E6%9E%90.html "),r("br")])],1)}),[],!1,null,null,null);e.default=s.exports}}]);