(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{1304:function(t,e,n){t.exports=n.p+"assets/img/original.173706f2.jpg"},1305:function(t,e,n){t.exports=n.p+"assets/img/read.244f44c0.jpg"},1306:function(t,e,n){t.exports=n.p+"assets/img/write.d3da0b9c.jpg"},1741:function(t,e,n){"use strict";n.r(e);var s=n(42),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),s("p",[t._v("musl是在Linux系统调用API之上构建的C标准库的实现，其中包括在基本语言标准POSIX中定义的接口，以及广泛认可的扩展。相比于glibc，musl轻巧，快速，简单并且协议友好，本文将以musl的fopen为切入点，结合源码介绍musl对文件的基本操作。\n"),s("br"),s("br")]),t._v(" "),s("h1",{attrs:{id:"数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),s("p",[t._v("musl涉及文件的关键数据结构如下，该结构体即为我们平时使用的FILE，本文重点关注4个函数指针（close、read、write和seek）和5个位置指针（读两个：rpos、rend，写三个：wend、wpos和wbase）即可。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("struct _IO_FILE {\n\tunsigned flags;\n\tunsigned char *rpos, *rend;\n\tint (*close)(FILE *);\n\tunsigned char *wend, *wpos;\n\tunsigned char *mustbezero_1;\n\tunsigned char *wbase;\n\tsize_t (*read)(FILE *, unsigned char *, size_t);\n\tsize_t (*write)(FILE *, const unsigned char *, size_t);\n\toff_t (*seek)(FILE *, off_t, int);\n\tunsigned char *buf;\n\tsize_t buf_size;\n\tFILE *prev, *next;\n\tint fd;\n\tint pipe_pid;\n\tlong lockcount;\n\tint mode;\n\tvolatile int lock;\n\tint lbf;\n\tvoid *cookie;\n\toff_t off;\n\tchar *getln_buf;\n\tvoid *mustbezero_2;\n\tunsigned char *shend;\n\toff_t shlim, shcnt;\n\tFILE *prev_locked, *next_locked;\n\tstruct __locale_struct *locale;\n};\n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("h1",{attrs:{id:"接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),s("h2",{attrs:{id:"fopen"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fopen"}},[t._v("#")]),t._v(" fopen")]),t._v(" "),s("p",[t._v("fopen的源码如下，逻辑非常简单，判断打开的模式，然后使用open系统调用从内核获取一个fd，随后通过__fdopen函数将fd封装为一个FILE，并为4个函数指针（close、read、write和seek）挂上默认的函数。"),s("br"),t._v("\nFILE初始状态可以用下图表示。最前面一段即为FILE的主体，接下来是一个名为UNGET的预留区域处理不缓冲时的场景（默认8字节），接下来便是musl预留的一段缓冲区，默认1024字节。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('FILE *fopen(const char *restrict filename, const char *restrict mode)\n{\n\tFILE *f;\n\tint fd;\n\tint flags;\n\n\t/* Check for valid initial mode character */\n\tif (!strchr("rwa", *mode)) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\n\t/* Compute the flags to pass to open() */\n\tflags = __fmodeflags(mode);\n\n\tfd = sys_open(filename, flags, 0666);\n\tif (fd < 0) return 0;\n\tif (flags & O_CLOEXEC)\n\t\t__syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);\n\n\tf = __fdopen(fd, mode);\n\tif (f) return f;\n\n\t__syscall(SYS_close, fd);\n\treturn 0;\n}\n\n...\n\nFILE *__fdopen(int fd, const char *mode)\n{\n\t...\n\n\t/* Allocate FILE+buffer or fail */\n\tif (!(f=malloc(sizeof *f + UNGET + BUFSIZ))) return 0;\n\n\t/* Zero-fill only the struct, not the buffer */\n\tmemset(f, 0, sizeof *f);\n\n\t...\n\n\tf->fd = fd;\n\tf->buf = (unsigned char *)f + sizeof *f + UNGET;\n\tf->buf_size = BUFSIZ;\n\n\t...\n\n\t/* Initialize op ptrs. No problem if some are unneeded. */\n\tf->read = __stdio_read;\n\tf->write = __stdio_write;\n\tf->seek = __stdio_seek;\n\tf->close = __stdio_close;\n\n\t...\n\n}\n')])])]),s("p",[s("br"),s("br")]),t._v(" "),s("center",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:n(1304)}})]),t._v(" "),s("br"),s("br"),t._v(" "),s("h2",{attrs:{id:"fclose"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fclose"}},[t._v("#")]),t._v(" fclose")]),t._v(" "),s("p",[t._v("fclose函数源码如下，这里只列出了关键步骤。将写缓冲的内容刷入文件，通过f->close(f)调用真正的close函数__stdio_close，通过系统调用关闭fd对应的文件，然后释放掉外部封装的数据结构。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("int fclose(FILE *f)\n{\n\tint r;\n\t\n\tFLOCK(f);\n\tr = fflush(f);\n\tr |= f->close(f);\n\tFUNLOCK(f);\n\n\t...\n\n\tfree(f->getln_buf);\n\tfree(f);\n\n\treturn r;\n}\n\n...\n\nint __stdio_close(FILE *f)\n{\n\treturn syscall(SYS_close, __aio_close(f->fd));\n}\n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("h2",{attrs:{id:"fread"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fread"}},[t._v("#")]),t._v(" fread")]),t._v(" "),s("p",[t._v("分析fread的时候我们把顺序反过来，先看_IO_FILE中的read成员，上文已提过该成员为指针函数，在fopen的时候初始化，fread最终会调用该函数，其源码如下。其核心思想是在满足用户读取len长度内容到buf之外，预读一部分到FILE中的缓冲区。"),s("br"),t._v("\n从iov结构体数组的初始化可知，第一个元素是用户的buf，第二个是FILE的缓冲区，即先读出给用户，然后再读到缓冲区，读到缓冲区的内容默认小于等于1023，为何不是1024？"),s("br"),t._v("\n让我们把视线重新放回到iov的初始化，其中第一个元素的起始地址确实是用户的地址，但是长度实际上减去了1，即iov[0]最多只会读出len - 1个元素，最后一个元素会放入iov[1]，在结尾时重新赋给buf[len - 1]，这么做的目的是使rpos指针在读取后偏移一个字节从而表明FILE的缓冲区已经有预读的内容。预读之后的指针情况可以用下图表示（与写相关的三个指针此时为空）。"),s("br"),t._v(" "),s("center",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:n(1305)}})]),t._v(" "),s("br"),s("br")],1),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("size_t __stdio_read(FILE *f, unsigned char *buf, size_t len)\n{\n\tstruct iovec iov[2] = {\n\t\t{ .iov_base = buf, .iov_len = len - !!f->buf_size },\n\t\t{ .iov_base = f->buf, .iov_len = f->buf_size }\n\t};\n\tssize_t cnt;\n\n\tcnt = iov[0].iov_len ? syscall(SYS_readv, f->fd, iov, 2)\n\t\t: syscall(SYS_read, f->fd, iov[1].iov_base, iov[1].iov_len);\n\tif (cnt <= 0) {\n\t\tf->flags |= cnt ? F_ERR : F_EOF;\n\t\treturn 0;\n\t}\n\tif (cnt <= iov[0].iov_len) return cnt;\n\tcnt -= iov[0].iov_len;\n\tf->rpos = f->buf;\n\tf->rend = f->buf + cnt;\n\tif (f->buf_size) buf[len-1] = *f->rpos++;\n\treturn len;\n}\n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("p",[t._v("接下来看fread函数，其源码如下。上文提到每次__stdio_read都会预读一部分内容，因此fread会优先通过memcpy从缓冲区读，如果读完仍不满足用户需求才会调用__stdio_read从文件中读取。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("size_t fread(void *restrict destv, size_t size, size_t nmemb, FILE *restrict f)\n{\n\tunsigned char *dest = destv;\n\tsize_t len = size*nmemb, l = len, k;\n\tif (!size) nmemb = 0;\n\n\tFLOCK(f);\n\n\tf->mode |= f->mode-1;\n\n\tif (f->rpos != f->rend) {\n\t\t/* First exhaust the buffer. */\n\t\tk = MIN(f->rend - f->rpos, l);\n\t\tmemcpy(dest, f->rpos, k);\n\t\tf->rpos += k;\n\t\tdest += k;\n\t\tl -= k;\n\t}\n\t\n\t/* Read the remainder directly */\n\tfor (; l; l-=k, dest+=k) {\n\t\tk = __toread(f) ? 0 : f->read(f, dest, l);\n\t\tif (!k) {\n\t\t\tFUNLOCK(f);\n\t\t\treturn (len-l)/size;\n\t\t}\n\t}\n\n\tFUNLOCK(f);\n\treturn nmemb;\n}\n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("p",[t._v("这里提一下fread在调用__stdio_read之前调用的一个函数__toread，其源码如下。该函数可以理解为读写模式的切换，如果上一次是写，由于读写共用一个缓冲区，因此需要先把写缓存刷入文件并把写相关的三个指针清零，然后再执行读操作，此外，__toread函数还负责判断文件是否可读。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("int __toread(FILE *f)\n{\n\tf->mode |= f->mode-1;\n\tif (f->wpos != f->wbase) f->write(f, 0, 0);\n\tf->wpos = f->wbase = f->wend = 0;\n\tif (f->flags & F_NORD) {\n\t\tf->flags |= F_ERR;\n\t\treturn EOF;\n\t}\n\tf->rpos = f->rend = f->buf + f->buf_size;\n\treturn (f->flags & F_EOF) ? EOF : 0;\n}\n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("h2",{attrs:{id:"fwrite"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fwrite"}},[t._v("#")]),t._v(" fwrite")]),t._v(" "),s("p",[t._v("同样还是先从__stdio_write来看，源码如下。其核心思想是先把用户buf中的内容写入到FILE提供的缓冲区，写满了之后才会往文件中写，相较__stdio_read来说比较简单，在完成一次__stdio_write并且未写满缓冲区的情况下，FILE的指针位置如下图所示。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)\n{\n\tstruct iovec iovs[2] = {\n\t\t{ .iov_base = f->wbase, .iov_len = f->wpos-f->wbase },\n\t\t{ .iov_base = (void *)buf, .iov_len = len }\n\t};\n\tstruct iovec *iov = iovs;\n\tsize_t rem = iov[0].iov_len + iov[1].iov_len;\n\tint iovcnt = 2;\n\tssize_t cnt;\n\tfor (;;) {\n\t\tcnt = syscall(SYS_writev, f->fd, iov, iovcnt);\n\t\tif (cnt == rem) {\n\t\t\tf->wend = f->buf + f->buf_size;\n\t\t\tf->wpos = f->wbase = f->buf;\n\t\t\treturn len;\n\t\t}\n\t\tif (cnt < 0) {\n\t\t\tf->wpos = f->wbase = f->wend = 0;\n\t\t\tf->flags |= F_ERR;\n\t\t\treturn iovcnt == 2 ? 0 : len-iov[0].iov_len;\n\t\t}\n\t\trem -= cnt;\n\t\tif (cnt > iov[0].iov_len) {\n\t\t\tcnt -= iov[0].iov_len;\n\t\t\tiov++; iovcnt--;\n\t\t}\n\t\tiov[0].iov_base = (char *)iov[0].iov_base + cnt;\n\t\tiov[0].iov_len -= cnt;\n\t}\n}\n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("center",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:n(1306)}})]),t._v(" "),s("br"),s("br"),t._v("\n接下来看fwirte函数，其源码如下。同样也是先通过__towrite切换模式，如果写缓冲区的剩余空间不足，则会调用__stdio_write，由上文可知，此时是先刷缓冲区的内容，然后才操作用户buf的内容。如果缓冲区空间充足则直接通过memcpy写入缓冲区。\n"),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("size_t __fwritex(const unsigned char *restrict s, size_t l, FILE *restrict f)\n{\n\tsize_t i=0;\n\n\tif (!f->wend && __towrite(f)) return 0;\n\n\tif (l > f->wend - f->wpos) return f->write(f, s, l);\n\n\tif (f->lbf >= 0) {\n\t\t/* Match /^(.*\\n|)/ */\n\t\tfor (i=l; i && s[i-1] != '\\n'; i--);\n\t\tif (i) {\n\t\t\tsize_t n = f->write(f, s, i);\n\t\t\tif (n < i) return n;\n\t\t\ts += i;\n\t\t\tl -= i;\n\t\t}\n\t}\n\n\tmemcpy(f->wpos, s, l);\n\tf->wpos += l;\n\treturn l+i;\n}\n\nsize_t fwrite(const void *restrict src, size_t size, size_t nmemb, FILE *restrict f)\n{\n\tsize_t k, l = size*nmemb;\n\tif (!size) nmemb = 0;\n\tFLOCK(f);\n\tk = __fwritex(src, l, f);\n\tFUNLOCK(f);\n\treturn k==l ? nmemb : k/size;\n}\n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("p",[t._v("类似于__toread，__towrite用作切换到写操作，源码如下。这里其实有个bug，我们在下文细说。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("int __towrite(FILE *f)\n{\n\tf->mode |= f->mode-1;\n\tif (f->flags & F_NOWR) {\n\t\tf->flags |= F_ERR;\n\t\treturn EOF;\n\t}\n\t/* Clear read buffer (easier than summoning nasal demons) */\n\tf->rpos = f->rend = 0;\n\n\t/* Activate write through the buffer. */\n\tf->wpos = f->wbase = f->buf;\n\tf->wend = f->buf + f->buf_size;\n\n\treturn 0;\n}\n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("h1",{attrs:{id:"一点不足"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一点不足"}},[t._v("#")]),t._v(" 一点不足")]),t._v(" "),s("p",[t._v("如果仔细对比__towrite和__toread的代码可以发现，二者其实并不“对称”，具体来说，__toread即切换到写之前会通过f->write(f, 0, 0)将写缓冲刷到文件，但是__towrite即切换到写时则是简单粗暴地把读相关的指针（rpos、rend）清理，这样做会有什么问题呢？我们看以下操作："),s("br")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"30pt"}},[t._v("步骤")])]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("动作")])]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("期望pos")])]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("实际pos")])])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"30pt"}},[t._v("1")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("写30")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("30")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("30")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"30pt"}},[t._v("2")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("返回开头")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("0")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("0")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"30pt"}},[t._v("3")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("读15")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("15")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("15")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"30pt"}},[t._v("4")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("写15")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("30")])]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[s("div",{staticStyle:{width:"50pt"}},[t._v("45")])])])])]),t._v(" "),s("p",[s("br"),s("br")]),t._v(" "),s("p",[t._v("如果在第4步执行完时通过fgetpos获取当前文件指针的位置，则会发现并非期望的30，而是45，事实上，第4步期望是覆盖文件的后15字节，实际上变成了追加写15字节，pos自然是45，这是为什么？"),s("br"),t._v("\n由上文可知，fread实际上会预读一部分内容，因此当我们在第三步读15时，实际上fread读了30即整个文件，至于这一步为何没有问题，可以看以下代码：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("off_t __ftello_unlocked(FILE *f)\n{\n\toff_t pos = f->seek(f, 0,\n\t\t(f->flags & F_APP) && f->wpos != f->wbase\n\t\t? SEEK_END : SEEK_CUR);\n\tif (pos < 0) return pos;\n\n\t/* Adjust for data in buffer. */\n\tif (f->rend)\n\t\tpos += f->rpos - f->rend;\n\telse if (f->wbase)\n\t\tpos += f->wpos - f->wbase;\n\treturn pos;\n}\n")])])]),s("p",[s("br"),s("br")]),t._v(" "),s("p",[t._v("fgetpos最终调用了__ftello_unlocked，该函数通过系统调用从内核获取文件pos的真实位置，然后会做一个矫正，具体来说，我们在第3步做了读操作，因此读指针rend非空，__ftello_unlocked会减去多读的内容，因此第3步没问题。但是到第4步，由于__towrite简单粗暴地把读指针清空，写的15字节内容直接放入了FILE的缓冲区，下一次读时这15字节会直接追加到文件的末尾。\n"),s("br"),t._v("\n对于这个问题，处理方式也很简单，在__towrite清理读指针之前把pos移动回多读之前的位置即可。"),s("br"),s("br")]),t._v(" "),s("h1",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),s("p",[t._v("本文结合musl的源码分析了fopen相关的接口实现。相较于glibc，musl的代码浅显易懂，当然也存在考虑不完善的问题。"),s("br"),t._v(" "),s("br")]),t._v(" "),s("h1",{attrs:{id:"文章推荐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文章推荐"}},[t._v("#")]),t._v(" 文章推荐")]),t._v(" "),s("p",[t._v("glibc malloc系列文章："),s("br"),t._v("\n    原理简析："),s("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc+malloc%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/glibc+malloc%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90.html "),s("br"),t._v("\n    数据结构："),s("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc+malloc%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90.html "),s("br"),t._v("\n    malloc："),s("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc+malloc%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90(%E4%BA%8C).html "),s("br"),t._v("\n    free："),s("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc+malloc%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90(%E4%B8%89).html "),s("br"),t._v(" "),s("br")]),t._v(" "),s("p",[t._v("glibc问题定位与分析系列文章："),s("br"),t._v("\n    memcpy 1k字节x86_64虚拟机性能下降分析："),s("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/memcpy_1k%E5%AD%97%E8%8A%82x86_64%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90.html "),s("br"),t._v("\n    调用栈问题分析："),s("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D--%E6%8E%A8%E6%A0%88%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.html "),s("br"),t._v(" "),s("br")]),t._v(" "),s("p",[t._v("    glibc locale使用简析："),s("br"),t._v("\n     https://www.openeuler.org/zh/blog/wangshuo/glibc%20locale%E4%BD%BF%E7%94%A8%E7%AE%80%E6%9E%90/glibc+locale%E4%BD%BF%E7%94%A8%E7%AE%80%E6%9E%90.html "),s("br")])],1)}),[],!1,null,null,null);e.default=r.exports}}]);