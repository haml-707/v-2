(window.webpackJsonp=window.webpackJsonp||[]).push([[307],{1739:function(t,e,a){"use strict";a.r(e);var n=a(42),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_1-问题背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-问题背景"}},[t._v("#")]),t._v(" 1 问题背景")]),t._v(" "),a("h2",{attrs:{id:"_1-1-问题现象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-问题现象"}},[t._v("#")]),t._v(" 1.1 问题现象")]),t._v(" "),a("p",[t._v("x86_64环境上运行memcpy 1k字节时虚拟机的性能比物理机下降了40倍。")]),t._v(" "),a("h2",{attrs:{id:"_1-2-软件信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-软件信息"}},[t._v("#")]),t._v(" 1.2 软件信息")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("软件项")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("版本信息")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("OS")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("openEuler 20.03 (LTS)")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("kernel")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("4.19.90-2003.4.0.0036.oe1.x86_64")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("glibc")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("2.28")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("gcc")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("7.3.0")])])])]),t._v(" "),a("h1",{attrs:{id:"_2-结论与解决方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-结论与解决方法"}},[t._v("#")]),t._v(" 2 结论与解决方法")]),t._v(" "),a("h2",{attrs:{id:"_2-1-结论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-结论"}},[t._v("#")]),t._v(" 2.1 结论")]),t._v(" "),a("p",[t._v("起虚拟机的xml文件没有开超线程导致memcpy L3 cache水线在物理机和虚拟机中存在差异，从而引起性能差异。")]),t._v(" "),a("h2",{attrs:{id:"_2-2-解决方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-解决方法"}},[t._v("#")]),t._v(" 2.2 解决方法")]),t._v(" "),a("h3",{attrs:{id:"方法一-虚拟机开超线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法一-虚拟机开超线程"}},[t._v("#")]),t._v(" 方法一 虚拟机开超线程")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<cpu mode='host-passthrough' check='none'>\n   ...\n  <topology sockets='2' cores='4' threads='2'/>\n  <feature policy='require' name='topoext'/>\n</cpu>\n")])])]),a("h3",{attrs:{id:"方法二-调整memcpy水线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法二-调整memcpy水线"}},[t._v("#")]),t._v(" 方法二 调整memcpy水线")]),t._v(" "),a("p",[t._v("以下为glibc社区推荐配置")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# export GLIBC_TUNABLES=glibc.tune.x86_non_temporal_threshold=$(($(getconf LEVEL3_CACHE_SIZE) * 3 / 4))\n")])])]),a("h1",{attrs:{id:"_3-memcpy算法综述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-memcpy算法综述"}},[t._v("#")]),t._v(" 3 memcpy算法综述")]),t._v(" "),a("p",[t._v("在glibc-2.28中，memcpy和memove共享一套逻辑，其实现算法在glibc的源码中有简要介绍：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S\n\n/* memmove/memcpy/mempcpy is implemented as:\n   1. Use overlapping load and store to avoid branch.\n   2. Load all sources into registers and store them together to avoid\n      possible address overlap between source and destination.\n   3. If size is 8 * VEC_SIZE or less, load all sources into registers\n      and store them together.\n   4. If address of destination > address of source, backward copy\n      4 * VEC_SIZE at a time with unaligned load and aligned store.\n      Load the first 4 * VEC and last VEC before the loop and store\n      them after the loop to support overlapping addresses.\n   5. Otherwise, forward copy 4 * VEC_SIZE at a time with unaligned\n      load and aligned store.  Load the last 4 * VEC and first VEC\n      before the loop and store them after the loop to support\n      overlapping addresses.\n   6. If size >= __x86_shared_non_temporal_threshold and there is no\n      overlap between destination and source, use non-temporal store\n      instead of aligned store.  */\n")])])]),a("p",[t._v("其中，如第6条所述，如果超过__x86_shared_non_temporal_threshold水线，将使用non-temporal store代替aligned store，本次性能下降问题就属于该场景。")]),t._v(" "),a("h1",{attrs:{id:"_4-执行逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-执行逻辑"}},[t._v("#")]),t._v(" 4 执行逻辑")]),t._v(" "),a("p",[t._v("x86环境上进程启动之前，会对水线进行一系列的初始化操作，本次涉及的水线初始化动作如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("sysdeps/x86/cacheinfo.c\n\n533       /* A value of 0 for the HTT bit indicates there is only a single\n534      logical processor.  */\n535       if (HAS_CPU_FEATURE (HTT))\n536     {\n          ...\n          计算threads\n          ...\n693     }\n\n        ...\n\n781   /* The large memcpy micro benchmark in glibc shows that 6 times of\n782      shared cache size is the approximate value above which non-temporal\n783      store becomes faster on a 8-core processor.  This is the 3/4 of the\n784      total shared cache size.  */\n785   __x86_shared_non_temporal_threshold\n786     = (cpu_features->non_temporal_threshold != 0\n787        ? cpu_features->non_temporal_threshold\n788        : __x86_shared_cache_size * threads * 3 / 4);\n")])])]),a("p",[t._v("可以看出，虚拟机在没有开超线程的情况下__x86_shared_non_temporal_threshold为0，而物理机为__x86_shared_cache_size * threads * 3 / 4. 当执行memcpy 1k操作时，会按照如下逻辑判断具体需要执行的分支，虚拟机和物理机的逻辑在此之后产生差别。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S\n\n455 #if (defined USE_MULTIARCH || VEC_SIZE == 16) && IS_IN (libc)\n456     /* Check non-temporal store threshold.  */\n457     cmpq    __x86_shared_non_temporal_threshold(%rip), %rdx\n458     ja  L(large_backward)\n459 #endif\n")])])]),a("p",[t._v("具体逻辑如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("物理机逻辑\nsysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S\n\n460 L(loop_4x_vec_backward):\n461     /* Copy 4 * VEC a time backward.  */\n462     VMOVU   (%rcx), %VEC(0)\n463     VMOVU   -VEC_SIZE(%rcx), %VEC(1)\n464     VMOVU   -(VEC_SIZE * 2)(%rcx), %VEC(2)\n465     VMOVU   -(VEC_SIZE * 3)(%rcx), %VEC(3)\n466     subq    $(VEC_SIZE * 4), %rcx\n467     subq    $(VEC_SIZE * 4), %rdx\n468     VMOVA   %VEC(0), (%r9)\n469     VMOVA   %VEC(1), -VEC_SIZE(%r9)\n470     VMOVA   %VEC(2), -(VEC_SIZE * 2)(%r9)\n471     VMOVA   %VEC(3), -(VEC_SIZE * 3)(%r9)\n472     subq    $(VEC_SIZE * 4), %r9\n473     cmpq    $(VEC_SIZE * 4), %rdx\n474     ja  L(loop_4x_vec_backward)\n475     /* Store the first 4 * VEC.  */\n476     VMOVU   %VEC(4), (%rdi)\n477     VMOVU   %VEC(5), VEC_SIZE(%rdi)\n478     VMOVU   %VEC(6), (VEC_SIZE * 2)(%rdi)\n479     VMOVU   %VEC(7), (VEC_SIZE * 3)(%rdi)\n480     /* Store the last VEC.  */\n481     VMOVU   %VEC(8), (%r11)\n482     VZEROUPPER\n483     ret\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("虚拟机逻辑\nsysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S\n\n528 L(loop_large_backward):\n529     /* Copy 4 * VEC a time backward with non-temporal stores.  */\n530     PREFETCH_ONE_SET (-1, (%rcx), -PREFETCHED_LOAD_SIZE * 2)\n531     PREFETCH_ONE_SET (-1, (%rcx), -PREFETCHED_LOAD_SIZE * 3)\n532     VMOVU   (%rcx), %VEC(0)\n533     VMOVU   -VEC_SIZE(%rcx), %VEC(1)\n534     VMOVU   -(VEC_SIZE * 2)(%rcx), %VEC(2)\n535     VMOVU   -(VEC_SIZE * 3)(%rcx), %VEC(3)\n536     subq    $PREFETCHED_LOAD_SIZE, %rcx\n537     subq    $PREFETCHED_LOAD_SIZE, %rdx\n538     VMOVNT  %VEC(0), (%r9)\n539     VMOVNT  %VEC(1), -VEC_SIZE(%r9)\n540     VMOVNT  %VEC(2), -(VEC_SIZE * 2)(%r9)\n541     VMOVNT  %VEC(3), -(VEC_SIZE * 3)(%r9)\n542     subq    $PREFETCHED_LOAD_SIZE, %r9\n543     cmpq    $PREFETCHED_LOAD_SIZE, %rdx\n544     ja  L(loop_large_backward)\n545     sfence\n546     /* Store the first 4 * VEC.  */\n547     VMOVU   %VEC(4), (%rdi)\n548     VMOVU   %VEC(5), VEC_SIZE(%rdi)\n549     VMOVU   %VEC(6), (VEC_SIZE * 2)(%rdi)\n550     VMOVU   %VEC(7), (VEC_SIZE * 3)(%rdi)\n551     /* Store the last VEC.  */\n552     VMOVU   %VEC(8), (%r11)\n553     VZEROUPPER\n554     ret\n")])])]),a("h1",{attrs:{id:"_5-指令差异分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-指令差异分析"}},[t._v("#")]),t._v(" 5 指令差异分析")]),t._v(" "),a("p",[t._v("从上文可知，物理机和虚拟机执行逻辑的最大区别在于mov指令，指令的定义如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("sysdeps/x86_64/memmove.S\n\n 23 #define PREFETCHNT  prefetchnta\n 24 #define VMOVNT      movntdq\n 25 /* Use movups and movaps for smaller code sizes.  */\n 26 #define VMOVU       movups\n 27 #define VMOVA       movaps\n")])])]),a("p",[t._v("可知，物理机逻辑使用的是movaps指令，特点是16字节对齐，而虚拟机逻辑使用的是movntdq指令，该指令是bypass main cache的，这里附上相关介绍。")]),t._v(" "),a("blockquote",[a("p",[t._v("https://stackoverflow.com/questions/14106477/how-do-non-temporal-instructions-work\nThe streaming read/write with non-temporal hints are typically used to reduce cache pollution (often with WC memory). The idea is that a small set of cache lines are reserved on the CPU for these instructions to use. Instead of loading a cache line into the main caches, it is loaded into this smaller cache.")]),t._v(" "),a("p",[t._v("The comment supposes the following behavior (but I cannot find any references that the hardware actually does this, one would need to measure or a solid source and it could vary from hardware to hardware): - Once the CPU sees that the store buffer is full and that it is aligned to a cache line, it will flush it directly to memory since the non-temporal write bypasses the main cache.")])]),t._v(" "),a("p",[t._v("通过分析上文的代码可知，movntdq以bypass main cache的方式将数据放入内存，因此性能自然不如movaps指令。")]),t._v(" "),a("p",[t._v("在与社区沟通后我们得知，社区采取的是一种折中策略。对于大块数据的memcpy操作，如果都走L3 cache，虽然能提升memcpy的性能，但是却会对整个系统的性能造成影响，因此制定了水线。")]),t._v(" "),a("blockquote",[a("p",[t._v("https://sourceware.org/pipermail/libc-alpha/2021-January/121510.html\n> The performance of memcpy 1024 has recovered. However, there is performance\n> reduce in host. This is test result (cycle):\n>\n> \t                      memcpy_10\t memcpy_1k\t memcpy_10k\t  memcpy_1m\t  memcpy_10m\n> before backport\t             8\t         34\t        187\t        130848\t   2325409\n> after backport\t             8\t         34\t        182\t        515156\t   5282603\n> Performance improvement\t   0.00%\t    0.00%\t    2.67%\t    -293.71%   -127.17%")]),t._v(" "),a("p",[t._v("I think this is expected because the large copies no longer stay within\nthe cache.  This is required to avoid blowing away the entire cache\ncontents for such large copies, negatively impacting whole system\nperformance.  This will of course not show up in a micro-benchmark.")])]),t._v(" "),a("h1",{attrs:{id:"_6-修改水线后"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-修改水线后"}},[t._v("#")]),t._v(" 6 修改水线后")]),t._v(" "),a("p",[t._v("通过之前的分析可知，虚拟机默认的水线为0，在此参考社区的推荐配置在虚拟机和物理机上进行验证，结果如下（单位cycle数）：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("物理机")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("memcpy_10")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("memcpy_1k")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("memcpy_10k")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("memcpy_1M")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("memcpy_10M")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("配置前")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("8")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("34")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("187")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("130848")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("2325409")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("配置后")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("8")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("34")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("182")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("515156")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("5282603")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("性能提升")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("0.00%")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("0.00%")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("2.67%")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-293.71%")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-127.17%")])])])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("虚拟机")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("memcpy_10")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("memcpy_1k")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("memcpy_10k")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("memcpy_1M")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("memcpy_10M")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("配置前")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("8")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("1269")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("4555")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("523740")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("5304273")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("配置后")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("8")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("35")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("183")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("509297")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("5260913")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("性能提升")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("0.00%")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("97.24%")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("95.98%")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("2.76%")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("0.82%")])])])]),t._v(" "),a("p",[t._v("对比虚拟机和物理机配置前后的数据可以发现，调整了水线后虚拟机和物理机的性能是一致的。同时，对于物理机，之前水线为__x86_shared_cache_size * threads * 3 / 4，修改后为__x86_shared_cache_size * 3 / 4，水线降低，更容易进入movntdq指令，因此会在1M以后有下降。")])])}),[],!1,null,null,null);e.default=r.exports}}]);