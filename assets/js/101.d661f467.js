(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{1301:function(t,e,n){t.exports=n.p+"assets/img/futex.4aec7434.jpg"},1302:function(t,e,n){t.exports=n.p+"assets/img/futex_wait.a2f97723.jpg"},1303:function(t,e,n){t.exports=n.p+"assets/img/futex_wake.5b656add.jpg"},1738:function(t,e,n){"use strict";n.r(e);var a=n(42),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("Futex是Fast Userspace mutexes的缩写，翻译过来就是快速用户空间互斥体。其设计思想是通过增加在用户态原子检查来决定是否陷入内核进行wait。关于用户态的逻辑这里暂且不表，接下来本文将结合linux源码介绍futex的基本功能。\n"),a("br")]),t._v(" "),a("p",[t._v("软件信息如下：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[a("div",{staticStyle:{width:"50pt"}},[t._v("软件项")])]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[a("div",{staticStyle:{width:"170pt"}},[t._v("版本信息")])])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("div",{staticStyle:{width:"50pt"}},[t._v("OS")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("div",{staticStyle:{width:"170pt"}},[t._v("openEuler 20.03 (LTS)")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("div",{staticStyle:{width:"50pt"}},[t._v("kernel")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("div",{staticStyle:{width:"170pt"}},[t._v("4.19.90-2003.4.0.0036.oe1.aarch64")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("div",{staticStyle:{width:"50pt"}},[t._v("glibc")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("div",{staticStyle:{width:"170pt"}},[t._v("2.28")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("div",{staticStyle:{width:"50pt"}},[t._v("gcc")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("div",{staticStyle:{width:"170pt"}},[t._v("7.3.0")])])])])]),t._v(" "),a("p",[a("br"),a("br")]),t._v(" "),a("h1",{attrs:{id:"原理简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理简介"}},[t._v("#")]),t._v(" 原理简介")]),t._v(" "),a("p",[t._v("Futex是一种用户态和内核态混合的同步机制，支持进程内的线程之间和进程间的同步锁操作。当用于线程同步时，因为线程共享虚拟内存空间，虚拟地址就可以唯一的标识出futex变量，即线程用同样的虚拟地址来访问futex变量。当用于进程间时，进程有独立的虚拟内存空间，因此只有通过mmap()让它们共享同一段物理地址空间来使用futex变量。"),a("br"),t._v("\n以进程同步为例，首先，同步的进程间通过mmap共享一段内存，futex变量就位于这段共享的内存中且操作是原子的，当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，如果没有竞争发生，则只修改futex，而不用再执行系统调用，仅当通过访问futex变量告诉进程有竞争发生时，才执行系统调用去完成相应的处理。"),a("br"),t._v("\n当任务需要陷入内容等待时最终会调用futex_wait，当需要唤醒其它任务时最终会调用futex_wake，这两个函数完成了最基本的futex机制，其简化版的定义如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//uaddr指向一个地址，val代表这个地址期待的值，当*uaddr==val时，才会进行wait\nint futex_wait(int *uaddr, int val);\n\n//唤醒n个在uaddr指向的锁变量上挂起等待的进程\nint futex_wake(int *uaddr, int n);\n")])])]),a("br"),t._v(" "),a("h1",{attrs:{id:"数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),a("p",[t._v("上文提到，futex变量创建于用户空间，在进程或线程间共享，当进程或线程想要进入临界区时，通常会判断futex变量是否满足条件，若满足则成功进入临界区，否则则阻塞在该futex变量上；当进程或线程将要离开临界区时，则会唤醒阻塞在futex变量上的其他进程或线程。在内核中通过struct futex_q结构将一个futex变量与一个挂起的进程（线程）关联起来，其定义以及关键成员的作用如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct futex_q {\n    struct plist_node list;        //链表节点\n    struct task_struct *task;      //挂起在该futex变量关联的进程（线程）\n    spinlock_t *lock_ptr;          //自旋锁，控制链表访问\n    union futex_key key;           //futex变量地址标识\n\n    //下面三个与优先级继承相关，在此不多介绍\n    struct futex_pi_state *pi_state;\n    struct rt_mutex_waiter *rt_waiter;\n    union futex_key *requeue_pi_key;\n     \n    u32 bitset;                    //类似掩码匹配\n};\n")])])]),a("br"),t._v(" "),a("p",[t._v("在内核中通过一个全局哈希表来维护所有挂起阻塞在futex变量上的进程（线程），不同的futex变量会根据其地址标识计算出一个hash key并定位到一个bucket上，因此挂起阻塞在同一个futex变量的所有进程（线程）会对应到同一个bucket上，数据结构如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//bucket\nstruct futex_hash_bucket {\n    //当前自旋等待哈希桶的waiter数目\n\tatomic_t waiters;\n\n    //自旋锁，用于控制chain的访问，\n    //struct futex_q中lock_ptr，就是引用其所在的bucket的自旋锁\n\tspinlock_t lock;\n\n\t//优先级链，与传统等待队列不同，futex使用优先级链表来实现等待队列，\n    //是为了实现优先级继承，从而解决优先级翻转问题\n\tstruct plist_head chain;\n} ____cacheline_aligned_in_smp;\n\n//全局哈希表\nstatic struct {\n\tstruct futex_hash_bucket *queues;\n\tunsigned long            hashsize;\n} __futex_data __read_mostly __aligned(2*sizeof(long));\n#define futex_queues   (__futex_data.queues)\n#define futex_hashsize (__futex_data.hashsize)\n")])])]),a("br"),t._v(" "),a("p",[t._v("上文提到进程（线程）对应的bucket为全局哈希表的value，这里展示一下哈希表的key，其结构如下。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("union futex_key {\n\tstruct {\n\t\tu64 i_seq;\n\t\tunsigned long pgoff;\n\t\tunsigned int offset;\n\t} shared;  //不同进程间通过文件共享futex变量，表明该变量在文件中的位置\n\n\tstruct {\n\t\tunion {\n\t\t\tstruct mm_struct *mm;\n\t\t\tu64 __tmp;\n\t\t};\n\t\tunsigned long address;\n\t\tunsigned int offset;\n\t} private;  //同一进程的不同线程共享futex变量，表明该变量在进程地址空间中的位置\n\n\tstruct {\n\t\tu64 ptr;\n\t\tunsigned long word;\n\t\tunsigned int offset;\n\t} both;\n};\n")])])]),a("br"),t._v("\nfutex_key是一个union类型的结构，可以给进程和线程使用。futex会根据用户态的uaddr和进程（线程）的信息填充futex_key，并通过jhash计算出一个全局哈希表的索引，从而对应到一个bucket，尝试获取同一个futex的进程（线程）会映射到同一个bucket，然后再根据futex_key中的值在bucket链表中找到其它进程（线程）。"),a("br"),t._v("\n几个结构体之间的关系如下图所示：\n"),a("center",[a("img",{staticStyle:{zoom:"50%"},attrs:{src:n(1301)}})]),t._v(" "),a("br"),a("br"),t._v(" "),a("h1",{attrs:{id:"源码分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码分析"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),a("h2",{attrs:{id:"futex前期操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#futex前期操作"}},[t._v("#")]),t._v(" futex前期操作")]),t._v(" "),a("p",[t._v("futex初始化的源码如下，可以看出在kernel启动的时候即完成了初始化。初始化的内容也比较简单，申请固定数量的bucket交由全局哈希表__futex_data管理，然后初始化每个bucket的链表的自旋锁。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('static int __init futex_init(void)\n{\n\n    ...\n\n#if CONFIG_BASE_SMALL\n\tfutex_hashsize = 16;\n#else\n\tfutex_hashsize = roundup_pow_of_two(256 * num_possible_cpus());\n#endif\n\n\tfutex_queues = alloc_large_system_hash("futex", sizeof(*futex_queues),\n\t\t\t\t\t       futex_hashsize, 0,\n\t\t\t\t\t       futex_hashsize < 256 ? HASH_SMALL : 0,\n\t\t\t\t\t       &futex_shift, NULL,\n\t\t\t\t\t       futex_hashsize, futex_hashsize);\n\tfutex_hashsize = 1UL << futex_shift;\n\n\tfutex_detect_cmpxchg();\n\n\tfor (i = 0; i < futex_hashsize; i++) {\n\t\tatomic_set(&futex_queues[i].waiters, 0);\n\t\tplist_head_init(&futex_queues[i].chain);\n\t\tspin_lock_init(&futex_queues[i].lock);\n\t}\n\n\treturn 0;\n}\ncore_initcall(futex_init);\n')])])]),a("br"),t._v(" "),a("p",[t._v("futex系统调用进入内核后都会先走到do_futex，源码如下。用户态需要确定入参（入参个数，具体操作等），在内核会根据入参来决定采取何种操作，本文作为futex的入门帖，仅需关注futex_wait和futex_wake即可。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,\n\t\tu32 __user *uaddr2, u32 val2, u32 val3)\n{\n\tint cmd = op & FUTEX_CMD_MASK;\n\tunsigned int flags = 0;\n\n    ...\n\n\tswitch (cmd) {\n\tcase FUTEX_WAIT:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\tfallthrough;\n\tcase FUTEX_WAIT_BITSET:\n\t\treturn futex_wait(uaddr, flags, val, timeout, val3);\n\tcase FUTEX_WAKE:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\tfallthrough;\n\tcase FUTEX_WAKE_BITSET:\n\t\treturn futex_wake(uaddr, flags, val, val3);\n\tcase FUTEX_REQUEUE:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, NULL, 0);\n\tcase FUTEX_CMP_REQUEUE:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 0);\n\tcase FUTEX_WAKE_OP:\n\t\treturn futex_wake_op(uaddr, flags, uaddr2, val, val2, val3);\n\tcase FUTEX_LOCK_PI:\n\t\treturn futex_lock_pi(uaddr, flags, timeout, 0);\n\tcase FUTEX_UNLOCK_PI:\n\t\treturn futex_unlock_pi(uaddr, flags);\n\tcase FUTEX_TRYLOCK_PI:\n\t\treturn futex_lock_pi(uaddr, flags, NULL, 1);\n\tcase FUTEX_WAIT_REQUEUE_PI:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\treturn futex_wait_requeue_pi(uaddr, flags, val, timeout, val3,\n\t\t\t\t\t     uaddr2);\n\tcase FUTEX_CMP_REQUEUE_PI:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 1);\n\t}\n\treturn -ENOSYS;\n}\n")])])]),a("p",[a("br"),a("br")]),t._v(" "),a("h2",{attrs:{id:"futex-wait分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#futex-wait分析"}},[t._v("#")]),t._v(" futex wait分析")]),t._v(" "),a("p",[t._v("futex的执行流程参考下图。\n"),a("center",[a("img",{staticStyle:{zoom:"70%"},attrs:{src:n(1302)}})]),t._v(" "),a("br"),a("br"),t._v("\nfutex源码如下，下面让我们结合流程图来分析源码。对于带超时的场景，futex wait会首先通过futex_setup_timer设置定时器。接下来调用futex_wait_setup函数，后者主要做了两件事，一是根据入参获取全局哈希表的key从而找到task所属的bucket并获取自旋锁；二是在入队之前最后判断"),a("em",[t._v("uaddr是否为预期值。如果")]),t._v("uaddr被更新即非预期值，则会重新返回用户态去抢锁。否则执行下一步，即调用futex_wait_queue_me。后者主要做了几件事：1、将当前的task插入等待队列；2、启动定时任务；3、触发重新调度。接下来当task能够继续执行时会判断自己是如何被唤醒的，并释放hrtimer退出。")],1),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("static int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,\n\t\t      ktime_t *abs_time, u32 bitset)\n{\n\n    ...\n\n\tto = futex_setup_timer(abs_time, &timeout, flags,\n\t\t\t       current->timer_slack_ns);\nretry:\n\t/*\n\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n\t * q.key refs.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\t/* unqueue_me() drops q.key ref */\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\n    ...\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n")])])]),a("p",[a("br"),a("br")]),t._v(" "),a("h2",{attrs:{id:"futex-wake分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#futex-wake分析"}},[t._v("#")]),t._v(" futex wake分析")]),t._v(" "),a("p",[t._v("futex_wake的执行流程如下。"),a("br"),t._v(" "),a("center",[a("img",{staticStyle:{zoom:"70%"},attrs:{src:n(1303)}})]),t._v(" "),a("br"),a("br")],1),t._v(" "),a("p",[t._v("futex_wake源码如下，首先是通过get_futex_key生成全局哈希表的key，并通过hash_futex找到对应的bucket。以上两步实际上在上文提到的futex_wait_setup函数中也被调用到。接下来会遍历bucket根据key找目前wait在当前futex的task，并将其从bucket取出放入临时队列wake_q。随后释放bucket的自旋锁并逐个唤醒wake_q中的task。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("static int\nfutex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\n    ...\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, FUTEX_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\thb = hash_futex(&key);\n\n\t/* Make sure we really have tasks to wakeup */\n\tif (!hb_waiters_pending(hb))\n\t\treturn ret;\n\n\tspin_lock(&hb->lock);\n\n\tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n\t\tif (match_futex (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check if one of the bits is set in both bitsets */\n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\n\twake_up_q(&wake_q);\n\treturn ret;\n}\n")])])]),a("p",[a("br"),a("br")]),t._v(" "),a("h1",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("本文结合linux中futex的源码简单介绍了其最基本的两个功能futex_wait和futex_wake，后续有机会将陆续介绍futex相关的其它实现。\n"),a("br"),a("br")]),t._v(" "),a("h1",{attrs:{id:"参考文献"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),a("p",[t._v("futex内核实现源码分析（1-3）：https://www.jianshu.com/p/8f4b8dd37cbf "),a("br"),t._v("\nlinux内核级同步机制--futex： https://cloud.tencent.com/developer/article/1474735 "),a("br"),t._v(" "),a("br"),a("br")])],1)}),[],!1,null,null,null);e.default=s.exports}}]);